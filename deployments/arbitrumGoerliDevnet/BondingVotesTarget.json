{
  "address": "0x6F51155f20c322A579A8996740973A7446F7BD55",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_controller",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newValue",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lastValue",
          "type": "uint256"
        }
      ],
      "name": "DecreasingValues",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "lastClaimRound",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxAllowed",
          "type": "uint256"
        }
      ],
      "name": "FutureLastClaimRound",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "queryRound",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxAllowed",
          "type": "uint256"
        }
      ],
      "name": "FutureLookup",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "checkpointRound",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxAllowedRound",
          "type": "uint256"
        }
      ],
      "name": "FutureTotalStakeCheckpoint",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "required",
          "type": "address"
        }
      ],
      "name": "InvalidCaller",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "checkpointRound",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "requiredRound",
          "type": "uint256"
        }
      ],
      "name": "InvalidStartRound",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "transcoder",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "round",
          "type": "uint256"
        }
      ],
      "name": "MissingEarningsPool",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "bondingManagerFunction",
          "type": "string"
        }
      ],
      "name": "MustCallBondingManager",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "delegator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "fromDelegate",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "toDelegate",
          "type": "address"
        }
      ],
      "name": "DelegateChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "delegate",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "previousBalance",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newBalance",
          "type": "uint256"
        }
      ],
      "name": "DelegateVotesChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "delegate",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "previousBalance",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newBalance",
          "type": "uint256"
        }
      ],
      "name": "DelegatorVotesChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "param",
          "type": "string"
        }
      ],
      "name": "ParameterUpdate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        }
      ],
      "name": "SetController",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CLOCK_MODE",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_startRound",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_bondedAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_delegateAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_delegatedAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_lastClaimRound",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_lastRewardRound",
          "type": "uint256"
        }
      ],
      "name": "checkpointBondingState",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_totalStake",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_round",
          "type": "uint256"
        }
      ],
      "name": "checkpointTotalActiveStake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "clock",
      "outputs": [
        {
          "internalType": "uint48",
          "name": "",
          "type": "uint48"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "contract IController",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "delegate",
      "outputs": [],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "delegateBySig",
      "outputs": [],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_round",
          "type": "uint256"
        }
      ],
      "name": "delegatedAt",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        }
      ],
      "name": "delegates",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_round",
          "type": "uint256"
        }
      ],
      "name": "getBondingStateAt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "delegateAddress",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_round",
          "type": "uint256"
        }
      ],
      "name": "getPastTotalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_round",
          "type": "uint256"
        }
      ],
      "name": "getPastVotes",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_round",
          "type": "uint256"
        }
      ],
      "name": "getTotalActiveStakeAt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        }
      ],
      "name": "getVotes",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        }
      ],
      "name": "hasCheckpoint",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_controller",
          "type": "address"
        }
      ],
      "name": "setController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "targetContractId",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x3e1e140ca4f41f7d1af4afee0a4adf394604d01ab103c1b6a798a6aec7399b16",
  "receipt": {
    "to": null,
    "from": "0xa7BeA8108b77905113c0b22c16806672c38d040b",
    "contractAddress": "0x6F51155f20c322A579A8996740973A7446F7BD55",
    "transactionIndex": 1,
    "gasUsed": "1431171",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5cc9a3c4ce431e3dbd069fa38dbf61a8b78bcad531224088260d6b13173edaa9",
    "transactionHash": "0x3e1e140ca4f41f7d1af4afee0a4adf394604d01ab103c1b6a798a6aec7399b16",
    "logs": [],
    "blockNumber": 35855115,
    "cumulativeGasUsed": "1431171",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x53Ea65f3E8B06d07DC1008276c5e4aa15126502B"
  ],
  "numDeployments": 2,
  "solcInputHash": "ff38c7bd49c32e9630f78a6ad5ac9666",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastValue\",\"type\":\"uint256\"}],\"name\":\"DecreasingValues\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastClaimRound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAllowed\",\"type\":\"uint256\"}],\"name\":\"FutureLastClaimRound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"queryRound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAllowed\",\"type\":\"uint256\"}],\"name\":\"FutureLookup\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"checkpointRound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAllowedRound\",\"type\":\"uint256\"}],\"name\":\"FutureTotalStakeCheckpoint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"required\",\"type\":\"address\"}],\"name\":\"InvalidCaller\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"checkpointRound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requiredRound\",\"type\":\"uint256\"}],\"name\":\"InvalidStartRound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transcoder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"MissingEarningsPool\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"bondingManagerFunction\",\"type\":\"string\"}],\"name\":\"MustCallBondingManager\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toDelegate\",\"type\":\"address\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"DelegateVotesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"DelegatorVotesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"param\",\"type\":\"string\"}],\"name\":\"ParameterUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"SetController\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CLOCK_MODE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startRound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bondedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_delegateAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_delegatedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastClaimRound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastRewardRound\",\"type\":\"uint256\"}],\"name\":\"checkpointBondingState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"checkpointTotalActiveStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clock\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"delegateBySig\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"delegatedAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"delegates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getBondingStateAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"delegateAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getPastTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getPastVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getTotalActiveStakeAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"hasCheckpoint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetContractId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Checkpointing logic for BondingManager state for historical stake calculations.\",\"kind\":\"dev\",\"methods\":{\"checkpointBondingState(address,uint256,uint256,address,uint256,uint256,uint256)\":{\"details\":\"Since we checkpoint \\\"delegator\\\" and \\\"transcoder\\\" states, this is called both for the delegator and for the transcoder when any change is made to the bonds, including when rewards are calculated or claimed.\",\"params\":{\"_account\":\"The account whose bonding state changed\",\"_bondedAmount\":\"From {BondingManager-Delegator-bondedAmount}\",\"_delegateAddress\":\"From {BondingManager-Delegator-delegateAddress}\",\"_delegatedAmount\":\"From {BondingManager-Transcoder-delegatedAmount}\",\"_lastClaimRound\":\"From {BondingManager-Delegator-lastClaimRound}\",\"_lastRewardRound\":\"From {BondingManager-Transcoder-lastRewardRound}\",\"_startRound\":\"The round from which the bonding state will be active. This is normally the next round.\"}},\"checkpointTotalActiveStake(uint256,uint256)\":{\"details\":\"This is called only from the {BondingManager-setCurrentRoundTotalActiveStake} function to set the total active stake in the current round.\",\"params\":{\"_round\":\"The round for which the total active stake is valid. This is normally the current round.\",\"_totalStake\":\"From {BondingManager-currentRoundTotalActiveStake}\"}},\"decimals()\":{\"details\":\"Returns the decimals places of the token.\"},\"delegatedAt(address,uint256)\":{\"details\":\"This is an addition to the IERC5805 interface to support our custom vote counting logic that allows delegators to override their transcoders votes. See {GaovernorCountingOverridable-_handleVoteOverrides}.Keep in mind that since this function should return the delegate at the end of the _round (or timepoint in OZ terms), we need to fetch the bonding state at the next round instead. That because the bonding state reflects the active stake in the current round, which is the snapshotted stake from the end of the previous round.\"},\"getBondingStateAt(address,uint256)\":{\"details\":\"In the case of delegators it is the amount they are delegating to a transcoder, while for transcoders this includes all the stake that has been delegated to them (including self-delegated).\",\"params\":{\"_account\":\"The account whose bonding state we want to get.\",\"_round\":\"The round for which we want to get the bonding state. Normally a proposal's vote start round.\"},\"returns\":{\"amount\":\"The active stake of the account at the given round including any accrued rewards. In case of transcoders this also includes all the amount delegated towards them by other delegators.\",\"delegateAddress\":\"The address the account delegated to. Will be equal to _account in case of transcoders.\"}},\"getPastTotalSupply(uint256)\":{\"details\":\"This value is the sum of all *active* stake, which is not necessarily the sum of all voting power. Bonded stake that is not part of the top 100 active transcoder set is still given voting power, but is not considered here.Keep in mind that since this function should return the votes at the end of the _round (or timepoint in OZ terms), we need to fetch the total active stake at the next round instead. That because the active stake in the current round is the snapshotted stake from the end of the previous round.\"},\"getPastVotes(address,uint256)\":{\"details\":\"Keep in mind that since this function should return the votes at the end of the _round (or timepoint in OZ terms), we need to fetch the bonding state at the next round instead. That because the bonding state reflects the active stake in the current round, which is the snapshotted stake from the end of the previous round.\"},\"getTotalActiveStakeAt(uint256)\":{\"details\":\"Gets the checkpointed total active stake at a given round.\",\"params\":{\"_round\":\"The round for which we want to get the total active stake.\"}},\"hasCheckpoint(address)\":{\"details\":\"This is meant to be called by a checkpoint initialization script once we deploy the checkpointing logic for the first time, so we can efficiently initialize the checkpoint state for all accounts in the system.\"},\"name()\":{\"details\":\"Returns the name of the token.\"},\"setController(address)\":{\"params\":{\"_controller\":\"Controller contract address\"}},\"symbol()\":{\"details\":\"Returns the symbol of the token.\"}},\"stateVariables\":{\"bondingCheckpoints\":{\"details\":\"Checkpoints by account (delegators and transcoders).\"},\"totalStakeCheckpoints\":{\"details\":\"Total active stake checkpoints.\"}},\"title\":\"BondingVotes\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"CLOCK_MODE()\":{\"notice\":\"Machine-readable description of the clock as specified in EIP-6372.\"},\"checkpointBondingState(address,uint256,uint256,address,uint256,uint256,uint256)\":{\"notice\":\"Called by the BondingManager when the bonding state of an account changes.\"},\"checkpointTotalActiveStake(uint256,uint256)\":{\"notice\":\"Called by the BondingManager when the total active stake changes.\"},\"clock()\":{\"notice\":\"Clock is set to match the current round, which is the checkpointing  method implemented here.\"},\"delegate(address)\":{\"notice\":\"Delegation through BondingVotes is not supported.\"},\"delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)\":{\"notice\":\"Delegation through BondingVotes is not supported.\"},\"delegatedAt(address,uint256)\":{\"notice\":\"Returns the delegate that _account had chosen in a specific round in the past. See `delegates()` above for more details.\"},\"delegates(address)\":{\"notice\":\"Returns the delegate that _account has chosen. This means the delegated transcoder address in case of delegators, and the account's own address for transcoders (self-delegated).\"},\"getBondingStateAt(address,uint256)\":{\"notice\":\"Gets the bonding state of an account at a given round.\"},\"getPastTotalSupply(uint256)\":{\"notice\":\"Returns the total supply of votes available at a specific round in the past.\"},\"getPastVotes(address,uint256)\":{\"notice\":\"Returns the amount of votes that `_account` had at a specific moment in the past. If the `clock()` is configured to use block numbers, this will return the value at the end of the corresponding block.\"},\"getVotes(address)\":{\"notice\":\"Returns the current amount of votes that `_account` has.\"},\"hasCheckpoint(address)\":{\"notice\":\"Returns whether an account already has any checkpoint.\"},\"setController(address)\":{\"notice\":\"Set controller. Only callable by current controller\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/bonding/BondingVotes.sol\":\"BondingVotes\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/governance/utils/IVotesUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/utils/IVotes.sol)\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\\n *\\n * _Available since v4.5._\\n */\\ninterface IVotesUpgradeable {\\n    /**\\n     * @dev Emitted when an account changes their delegate.\\n     */\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    /**\\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\\n     */\\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\\n\\n    /**\\n     * @dev Returns the current amount of votes that `account` has.\\n     */\\n    function getVotes(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\\n     */\\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\\n     *\\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\\n     * vote.\\n     */\\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the delegate that `account` has chosen.\\n     */\\n    function delegates(address account) external view returns (address);\\n\\n    /**\\n     * @dev Delegates votes from the sender to `delegatee`.\\n     */\\n    function delegate(address delegatee) external;\\n\\n    /**\\n     * @dev Delegates votes from signer to `delegatee`.\\n     */\\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\\n}\\n\",\"keccak256\":\"0x2d600bbef9320309cd2a86c1d087eb9d6dbcc00430713ee54bbc5c5a2a11ba31\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC5805Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5805.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../governance/utils/IVotesUpgradeable.sol\\\";\\nimport \\\"./IERC6372Upgradeable.sol\\\";\\n\\ninterface IERC5805Upgradeable is IERC6372Upgradeable, IVotesUpgradeable {}\\n\",\"keccak256\":\"0x19848eec9045c8b91f1ab6b1853966443e3e36bcbc307593ed37a9f0df179d69\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC6372Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC6372Upgradeable {\\n    /**\\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\\n     */\\n    function clock() external view returns (uint48);\\n\\n    /**\\n     * @dev Description of the clock\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CLOCK_MODE() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x3026befd6d69d1b46960bdc35a2ad37c0e1352f26983ee3728dd61fd32aa308a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Arrays.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Arrays.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./StorageSlot.sol\\\";\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary Arrays {\\n    using StorageSlot for bytes32;\\n\\n    /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\\n        bytes32 slot;\\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\\n        // following https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getAddressSlot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\\n        bytes32 slot;\\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\\n        // following https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getBytes32Slot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\\n        bytes32 slot;\\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\\n        // following https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getUint256Slot();\\n    }\\n}\\n\",\"keccak256\":\"0x104a08fc99d01f2229044fe3db7b3e0375b5d93cd7203f11db6ecdc9c8c8b0b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf09e68aa0dc6722a25bc46490e8d48ed864466d17313b8a0b254c36b54e49899\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x52a8cfb0f5239d11b457dcdd1b326992ef672714ca8da71a157255bddd13f3ad\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x58b21219689909c4f8339af00813760337f7e2e7f169a97fe49e2896dcfb3b9a\",\"license\":\"MIT\"},\"contracts/IController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./zeppelin/Pausable.sol\\\";\\n\\nabstract contract IController is Pausable {\\n    event SetContractInfo(bytes32 id, address contractAddress, bytes20 gitCommitHash);\\n\\n    function setContractInfo(\\n        bytes32 _id,\\n        address _contractAddress,\\n        bytes20 _gitCommitHash\\n    ) external virtual;\\n\\n    function updateController(bytes32 _id, address _controller) external virtual;\\n\\n    function getContract(bytes32 _id) public view virtual returns (address);\\n}\\n\",\"keccak256\":\"0x34ea30a2b44d0cbec58fc1d703476ff0085b0fdadab0cd65c35c00b8867f7546\",\"license\":\"MIT\"},\"contracts/IManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IManager {\\n    event SetController(address controller);\\n    event ParameterUpdate(string param);\\n\\n    function setController(address _controller) external;\\n}\\n\",\"keccak256\":\"0xc179e4cecc593741514237d5194b4aaac6b829789629fa19ed04f572a8530481\",\"license\":\"MIT\"},\"contracts/Manager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./IManager.sol\\\";\\nimport \\\"./IController.sol\\\";\\n\\ncontract Manager is IManager {\\n    // Controller that contract is registered with\\n    IController public controller;\\n\\n    // Check if sender is controller\\n    modifier onlyController() {\\n        _onlyController();\\n        _;\\n    }\\n\\n    // Check if sender is controller owner\\n    modifier onlyControllerOwner() {\\n        _onlyControllerOwner();\\n        _;\\n    }\\n\\n    // Check if controller is not paused\\n    modifier whenSystemNotPaused() {\\n        _whenSystemNotPaused();\\n        _;\\n    }\\n\\n    // Check if controller is paused\\n    modifier whenSystemPaused() {\\n        _whenSystemPaused();\\n        _;\\n    }\\n\\n    constructor(address _controller) {\\n        controller = IController(_controller);\\n    }\\n\\n    /**\\n     * @notice Set controller. Only callable by current controller\\n     * @param _controller Controller contract address\\n     */\\n    function setController(address _controller) external onlyController {\\n        controller = IController(_controller);\\n\\n        emit SetController(_controller);\\n    }\\n\\n    function _onlyController() private view {\\n        require(msg.sender == address(controller), \\\"caller must be Controller\\\");\\n    }\\n\\n    function _onlyControllerOwner() private view {\\n        require(msg.sender == controller.owner(), \\\"caller must be Controller owner\\\");\\n    }\\n\\n    function _whenSystemNotPaused() private view {\\n        require(!controller.paused(), \\\"system is paused\\\");\\n    }\\n\\n    function _whenSystemPaused() private view {\\n        require(controller.paused(), \\\"system is not paused\\\");\\n    }\\n}\\n\",\"keccak256\":\"0xc415e3f42da9f82ddd5953031f3f26aed824368fcc34d3b8a17015bfe80dc109\",\"license\":\"MIT\"},\"contracts/ManagerProxyTarget.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./Manager.sol\\\";\\n\\n/**\\n * @title ManagerProxyTarget\\n * @notice The base contract that target contracts used by a proxy contract should inherit from\\n * @dev Both the target contract and the proxy contract (implemented as ManagerProxy) MUST inherit from ManagerProxyTarget in order to guarantee\\n that both contracts have the same storage layout. Differing storage layouts in a proxy contract and target contract can\\n potentially break the delegate proxy upgradeability mechanism\\n */\\nabstract contract ManagerProxyTarget is Manager {\\n    // Used to look up target contract address in controller's registry\\n    bytes32 public targetContractId;\\n}\\n\",\"keccak256\":\"0x920bcc2def240e06272dc06cbcb9f12976f1698cd4f1020c165af25ee837e553\",\"license\":\"MIT\"},\"contracts/bonding/BondingManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"../ManagerProxyTarget.sol\\\";\\nimport \\\"./IBondingManager.sol\\\";\\nimport \\\"../libraries/SortedDoublyLL.sol\\\";\\nimport \\\"../libraries/MathUtils.sol\\\";\\nimport \\\"../libraries/PreciseMathUtils.sol\\\";\\nimport \\\"./libraries/EarningsPool.sol\\\";\\nimport \\\"./libraries/EarningsPoolLIP36.sol\\\";\\nimport \\\"../token/ILivepeerToken.sol\\\";\\nimport \\\"../token/IMinter.sol\\\";\\nimport \\\"../rounds/IRoundsManager.sol\\\";\\nimport \\\"../snapshots/IMerkleSnapshot.sol\\\";\\nimport \\\"./IBondingVotes.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n * @title BondingManager\\n * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol\\n */\\ncontract BondingManager is ManagerProxyTarget, IBondingManager {\\n    using SafeMath for uint256;\\n    using SortedDoublyLL for SortedDoublyLL.Data;\\n    using EarningsPool for EarningsPool.Data;\\n    using EarningsPoolLIP36 for EarningsPool.Data;\\n\\n    // Constants\\n    // Occurances are replaced at compile time\\n    // and computed to a single value if possible by the optimizer\\n    uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;\\n\\n    // Time between unbonding and possible withdrawl in rounds\\n    uint64 public unbondingPeriod;\\n\\n    // Represents a transcoder's current state\\n    struct Transcoder {\\n        uint256 lastRewardRound; // Last round that the transcoder called reward\\n        uint256 rewardCut; // % of reward paid to transcoder by a delegator\\n        uint256 feeShare; // % of fees paid to delegators by transcoder\\n        mapping(uint256 => EarningsPool.Data) earningsPoolPerRound; // Mapping of round => earnings pool for the round\\n        uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active\\n        uint256 activationRound; // Round in which the transcoder became active - 0 if inactive\\n        uint256 deactivationRound; // Round in which the transcoder will become inactive\\n        uint256 activeCumulativeRewards; // The transcoder's cumulative rewards that are active in the current round\\n        uint256 cumulativeRewards; // The transcoder's cumulative rewards (earned via the its active staked rewards and its reward cut).\\n        uint256 cumulativeFees; // The transcoder's cumulative fees (earned via the its active staked rewards and its fee share)\\n        uint256 lastFeeRound; // Latest round in which the transcoder received fees\\n    }\\n\\n    // The various states a transcoder can be in\\n    enum TranscoderStatus {\\n        NotRegistered,\\n        Registered\\n    }\\n\\n    // Represents a delegator's current state\\n    struct Delegator {\\n        uint256 bondedAmount; // The amount of bonded tokens\\n        uint256 fees; // The amount of fees collected\\n        address delegateAddress; // The address delegated to\\n        uint256 delegatedAmount; // The amount of tokens delegated to the delegator\\n        uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone\\n        uint256 lastClaimRound; // The last round during which the delegator claimed its earnings\\n        uint256 nextUnbondingLockId; // ID for the next unbonding lock created\\n        mapping(uint256 => UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID => unbonding lock\\n    }\\n\\n    // The various states a delegator can be in\\n    enum DelegatorStatus {\\n        Pending,\\n        Bonded,\\n        Unbonded\\n    }\\n\\n    // Represents an amount of tokens that are being unbonded\\n    struct UnbondingLock {\\n        uint256 amount; // Amount of tokens being unbonded\\n        uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn\\n    }\\n\\n    // Keep track of the known transcoders and delegators\\n    mapping(address => Delegator) private delegators;\\n    mapping(address => Transcoder) private transcoders;\\n\\n    // The total active stake (sum of the stake of active set members) for the current round\\n    uint256 public currentRoundTotalActiveStake;\\n    // The total active stake (sum of the stake of active set members) for the next round\\n    uint256 public nextRoundTotalActiveStake;\\n\\n    // The transcoder pool is used to keep track of the transcoders that are eligible for activation.\\n    // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders\\n    // in the pool are locked into the active set for round N + 1\\n    SortedDoublyLL.Data private transcoderPool;\\n\\n    // The % of newly minted rewards to be routed to the treasury. Represented as a PreciseMathUtils percPoint value.\\n    uint256 public treasuryRewardCutRate;\\n    // The value for `treasuryRewardCutRate` to be set on the next round initialization.\\n    uint256 public nextRoundTreasuryRewardCutRate;\\n\\n    // If the balance of the treasury in LPT is above this value, automatic treasury contributions will halt.\\n    uint256 public treasuryBalanceCeiling;\\n\\n    // Check if sender is TicketBroker\\n    modifier onlyTicketBroker() {\\n        _onlyTicketBroker();\\n        _;\\n    }\\n\\n    // Check if sender is RoundsManager\\n    modifier onlyRoundsManager() {\\n        _onlyRoundsManager();\\n        _;\\n    }\\n\\n    // Check if sender is Verifier\\n    modifier onlyVerifier() {\\n        _onlyVerifier();\\n        _;\\n    }\\n\\n    // Check if current round is initialized\\n    modifier currentRoundInitialized() {\\n        _currentRoundInitialized();\\n        _;\\n    }\\n\\n    // Automatically claim earnings from lastClaimRound through the current round\\n    modifier autoClaimEarnings(address _delegator) {\\n        _autoClaimEarnings(_delegator);\\n        _;\\n    }\\n\\n    modifier autoCheckpoint(address account) {\\n        _;\\n        checkpointBondingState(account);\\n    }\\n\\n    /**\\n     * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\\n     * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions\\n     * should be used to initialize state variables post-deployment:\\n     * - setUnbondingPeriod()\\n     * - setNumActiveTranscoders()\\n     * - setMaxEarningsClaimsRounds()\\n     * @param _controller Address of Controller that this contract will be registered with\\n     */\\n    constructor(address _controller) Manager(_controller) {}\\n\\n    /**\\n     * @notice Set unbonding period. Only callable by Controller owner\\n     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal\\n     */\\n    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {\\n        unbondingPeriod = _unbondingPeriod;\\n\\n        emit ParameterUpdate(\\\"unbondingPeriod\\\");\\n    }\\n\\n    /**\\n     * @notice Set treasury reward cut rate. Only callable by Controller owner\\n     * @param _cutRate Percentage of newly minted rewards to route to the treasury. Must be a valid PreciseMathUtils\\n     * percentage (<100% specified with 27-digits precision).\\n     */\\n    function setTreasuryRewardCutRate(uint256 _cutRate) external onlyControllerOwner {\\n        _setTreasuryRewardCutRate(_cutRate);\\n    }\\n\\n    function _setTreasuryRewardCutRate(uint256 _cutRate) internal {\\n        require(PreciseMathUtils.validPerc(_cutRate), \\\"_cutRate is invalid precise percentage\\\");\\n\\n        nextRoundTreasuryRewardCutRate = _cutRate;\\n\\n        emit ParameterUpdate(\\\"nextRoundTreasuryRewardCutRate\\\");\\n    }\\n\\n    /**\\n     * @notice Set treasury balance ceiling. Only callable by Controller owner\\n     * @param _ceiling Balance at which treasury reward contributions should halt. Specified in LPT fractional units\\n     * (18-digit precision).\\n     */\\n    function setTreasuryBalanceCeiling(uint256 _ceiling) external onlyControllerOwner {\\n        treasuryBalanceCeiling = _ceiling;\\n\\n        emit ParameterUpdate(\\\"treasuryBalanceCeiling\\\");\\n    }\\n\\n    /**\\n     * @notice Set maximum number of active transcoders. Only callable by Controller owner\\n     * @param _numActiveTranscoders Number of active transcoders\\n     */\\n    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {\\n        transcoderPool.setMaxSize(_numActiveTranscoders);\\n\\n        emit ParameterUpdate(\\\"numActiveTranscoders\\\");\\n    }\\n\\n    /**\\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it\\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR\\n     * @param _rewardCut % of reward paid to transcoder by a delegator\\n     * @param _feeShare % of fees paid to delegators by a transcoder\\n     */\\n    function transcoder(uint256 _rewardCut, uint256 _feeShare) external {\\n        transcoderWithHint(_rewardCut, _feeShare, address(0), address(0));\\n    }\\n\\n    /**\\n     * @notice Delegate stake towards a specific address\\n     * @param _amount The amount of tokens to stake\\n     * @param _to The address of the transcoder to stake towards\\n     */\\n    function bond(uint256 _amount, address _to) external {\\n        bondWithHint(_amount, _to, address(0), address(0), address(0), address(0));\\n    }\\n\\n    /**\\n     * @notice Unbond an amount of the delegator's bonded stake\\n     * @param _amount Amount of tokens to unbond\\n     */\\n    function unbond(uint256 _amount) external {\\n        unbondWithHint(_amount, address(0), address(0));\\n    }\\n\\n    /**\\n     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status\\n     * @param _unbondingLockId ID of unbonding lock to rebond with\\n     */\\n    function rebond(uint256 _unbondingLockId) external {\\n        rebondWithHint(_unbondingLockId, address(0), address(0));\\n    }\\n\\n    /**\\n     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status\\n     * @param _to Address of delegate\\n     * @param _unbondingLockId ID of unbonding lock to rebond with\\n     */\\n    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {\\n        rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0));\\n    }\\n\\n    /**\\n     * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period\\n     * @param _unbondingLockId ID of unbonding lock to withdraw with\\n     */\\n    function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {\\n        Delegator storage del = delegators[msg.sender];\\n        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\\n\\n        require(isValidUnbondingLock(msg.sender, _unbondingLockId), \\\"invalid unbonding lock ID\\\");\\n        require(\\n            lock.withdrawRound <= roundsManager().currentRound(),\\n            \\\"withdraw round must be before or equal to the current round\\\"\\n        );\\n\\n        uint256 amount = lock.amount;\\n        uint256 withdrawRound = lock.withdrawRound;\\n        // Delete unbonding lock\\n        delete del.unbondingLocks[_unbondingLockId];\\n\\n        // Tell Minter to transfer stake (LPT) to the delegator\\n        minter().trustedTransferTokens(msg.sender, amount);\\n\\n        emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound);\\n    }\\n\\n    /**\\n     * @notice Withdraws fees to the caller\\n     */\\n    function withdrawFees(address payable _recipient, uint256 _amount)\\n        external\\n        whenSystemNotPaused\\n        currentRoundInitialized\\n        autoClaimEarnings(msg.sender)\\n    {\\n        require(_recipient != address(0), \\\"invalid recipient\\\");\\n        uint256 fees = delegators[msg.sender].fees;\\n        require(fees >= _amount, \\\"insufficient fees to withdraw\\\");\\n        delegators[msg.sender].fees = fees.sub(_amount);\\n\\n        // Tell Minter to transfer fees (ETH) to the address\\n        minter().trustedWithdrawETH(_recipient, _amount);\\n\\n        emit WithdrawFees(msg.sender, _recipient, _amount);\\n    }\\n\\n    /**\\n     * @notice Mint token rewards for an active transcoder and its delegators\\n     */\\n    function reward() external {\\n        rewardWithHint(address(0), address(0));\\n    }\\n\\n    /**\\n     * @notice Update transcoder's fee pool. Only callable by the TicketBroker\\n     * @param _transcoder Transcoder address\\n     * @param _fees Fees to be added to the fee pool\\n     */\\n    function updateTranscoderWithFees(\\n        address _transcoder,\\n        uint256 _fees,\\n        uint256 _round\\n    ) external whenSystemNotPaused onlyTicketBroker {\\n        // Silence unused param compiler warning\\n        _round;\\n\\n        require(isRegisteredTranscoder(_transcoder), \\\"transcoder must be registered\\\");\\n\\n        uint256 currentRound = roundsManager().currentRound();\\n\\n        Transcoder storage t = transcoders[_transcoder];\\n\\n        uint256 lastRewardRound = t.lastRewardRound;\\n        uint256 activeCumulativeRewards = t.activeCumulativeRewards;\\n\\n        // LIP-36: Add fees for the current round instead of '_round'\\n        // https://github.com/livepeer/LIPs/issues/35#issuecomment-673659199\\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\\n        EarningsPool.Data memory prevEarningsPool = latestCumulativeFactorsPool(t, currentRound.sub(1));\\n\\n        // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare', 'transcoderRewardCut' and 'totalStake'\\n        // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected\\n        // for cumulative fee calculation this would result in division by zero.\\n        if (currentRound > lastRewardRound) {\\n            earningsPool.setCommission(t.rewardCut, t.feeShare);\\n\\n            uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\\n            if (lastUpdateRound < currentRound) {\\n                earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\\n            }\\n\\n            // If reward() has not been called yet in the current round, then the transcoder's activeCumulativeRewards has not\\n            // yet been set in for the round. When the transcoder calls reward() its activeCumulativeRewards will be set to its\\n            // current cumulativeRewards. So, we can just use the transcoder's cumulativeRewards here because this will become\\n            // the transcoder's activeCumulativeRewards if it calls reward() later on in the current round\\n            activeCumulativeRewards = t.cumulativeRewards;\\n        }\\n\\n        uint256 totalStake = earningsPool.totalStake;\\n        if (prevEarningsPool.cumulativeRewardFactor == 0 && lastRewardRound == currentRound) {\\n            // if transcoder called reward for 'currentRound' but not for 'currentRound - 1' (missed reward call)\\n            // retroactively calculate what its cumulativeRewardFactor would have been for 'currentRound - 1' (cfr. previous lastRewardRound for transcoder)\\n            // based on rewards for currentRound\\n            IMinter mtr = minter();\\n            uint256 rewards = PreciseMathUtils.percOf(\\n                mtr.currentMintableTokens().add(mtr.currentMintedTokens()),\\n                totalStake,\\n                currentRoundTotalActiveStake\\n            );\\n\\n            // Deduct what would have been the treasury rewards\\n            uint256 treasuryRewards = MathUtils.percOf(rewards, treasuryRewardCutRate);\\n            rewards = rewards.sub(treasuryRewards);\\n\\n            uint256 transcoderCommissionRewards = MathUtils.percOf(rewards, earningsPool.transcoderRewardCut);\\n            uint256 delegatorsRewards = rewards.sub(transcoderCommissionRewards);\\n\\n            prevEarningsPool.cumulativeRewardFactor = PreciseMathUtils.percOf(\\n                earningsPool.cumulativeRewardFactor,\\n                totalStake,\\n                delegatorsRewards.add(totalStake)\\n            );\\n        }\\n\\n        uint256 delegatorsFees = MathUtils.percOf(_fees, earningsPool.transcoderFeeShare);\\n        uint256 transcoderCommissionFees = _fees.sub(delegatorsFees);\\n        // Calculate the fees earned by the transcoder's earned rewards\\n        uint256 transcoderRewardStakeFees = PreciseMathUtils.percOf(\\n            delegatorsFees,\\n            activeCumulativeRewards,\\n            totalStake\\n        );\\n        // Track fees earned by the transcoder based on its earned rewards and feeShare\\n        t.cumulativeFees = t.cumulativeFees.add(transcoderRewardStakeFees).add(transcoderCommissionFees);\\n        // Update cumulative fee factor with new fees\\n        // The cumulativeFeeFactor is used to calculate fees for all delegators including the transcoder (self-delegated)\\n        // Note that delegatorsFees includes transcoderRewardStakeFees, but no delegator will claim that amount using\\n        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeFees field\\n        earningsPool.updateCumulativeFeeFactor(prevEarningsPool, delegatorsFees);\\n\\n        t.lastFeeRound = currentRound;\\n    }\\n\\n    /**\\n     * @notice Slash a transcoder. Only callable by the Verifier\\n     * @param _transcoder Transcoder address\\n     * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder\\n     * @param _slashAmount Percentage of transcoder bond to be slashed\\n     * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder\\n     */\\n    function slashTranscoder(\\n        address _transcoder,\\n        address _finder,\\n        uint256 _slashAmount,\\n        uint256 _finderFee\\n    ) external whenSystemNotPaused onlyVerifier autoClaimEarnings(_transcoder) autoCheckpoint(_transcoder) {\\n        Delegator storage del = delegators[_transcoder];\\n\\n        if (del.bondedAmount > 0) {\\n            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);\\n\\n            // If active transcoder, resign it\\n            if (transcoderPool.contains(_transcoder)) {\\n                resignTranscoder(_transcoder);\\n            }\\n\\n            // Decrease bonded stake\\n            del.bondedAmount = del.bondedAmount.sub(penalty);\\n\\n            // If still bonded decrease delegate's delegated amount\\n            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {\\n                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(\\n                    penalty\\n                );\\n            }\\n\\n            // Account for penalty\\n            uint256 burnAmount = penalty;\\n\\n            // Award finder fee if there is a finder address\\n            if (_finder != address(0)) {\\n                uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);\\n                minter().trustedTransferTokens(_finder, finderAmount);\\n\\n                // Minter burns the slashed funds - finder reward\\n                minter().trustedBurnTokens(burnAmount.sub(finderAmount));\\n\\n                emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);\\n            } else {\\n                // Minter burns the slashed funds\\n                minter().trustedBurnTokens(burnAmount);\\n\\n                emit TranscoderSlashed(_transcoder, address(0), penalty, 0);\\n            }\\n        } else {\\n            emit TranscoderSlashed(_transcoder, _finder, 0, 0);\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round\\n     * @param _endRound The last round for which to claim token pools shares for a delegator\\n     */\\n    function claimEarnings(uint256 _endRound)\\n        external\\n        whenSystemNotPaused\\n        currentRoundInitialized\\n        autoCheckpoint(msg.sender)\\n    {\\n        // Silence unused param compiler warning\\n        _endRound;\\n\\n        _autoClaimEarnings(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager\\n     */\\n    function setCurrentRoundTotalActiveStake() external onlyRoundsManager {\\n        currentRoundTotalActiveStake = nextRoundTotalActiveStake;\\n\\n        if (nextRoundTreasuryRewardCutRate != treasuryRewardCutRate) {\\n            treasuryRewardCutRate = nextRoundTreasuryRewardCutRate;\\n            // The treasury cut rate changes in a delayed fashion so we want to emit the parameter update event here\\n            emit ParameterUpdate(\\\"treasuryRewardCutRate\\\");\\n        }\\n\\n        bondingVotes().checkpointTotalActiveStake(currentRoundTotalActiveStake, roundsManager().currentRound());\\n    }\\n\\n    /**\\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint\\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the\\n     * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will\\n     * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.\\n     * See SortedDoublyLL.sol for details on list hints\\n     * @param _rewardCut % of reward paid to transcoder by a delegator\\n     * @param _feeShare % of fees paid to delegators by a transcoder\\n     * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool\\n     * @param _newPosNext Address of next transcoder in pool if the caller joins the pool\\n     */\\n    function transcoderWithHint(\\n        uint256 _rewardCut,\\n        uint256 _feeShare,\\n        address _newPosPrev,\\n        address _newPosNext\\n    ) public whenSystemNotPaused currentRoundInitialized {\\n        require(!roundsManager().currentRoundLocked(), \\\"can't update transcoder params, current round is locked\\\");\\n        require(MathUtils.validPerc(_rewardCut), \\\"invalid rewardCut percentage\\\");\\n        require(MathUtils.validPerc(_feeShare), \\\"invalid feeShare percentage\\\");\\n        require(isRegisteredTranscoder(msg.sender), \\\"transcoder must be registered\\\");\\n\\n        Transcoder storage t = transcoders[msg.sender];\\n        uint256 currentRound = roundsManager().currentRound();\\n\\n        require(\\n            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,\\n            \\\"caller can't be active or must have already called reward for the current round\\\"\\n        );\\n\\n        t.rewardCut = _rewardCut;\\n        t.feeShare = _feeShare;\\n\\n        if (!transcoderPool.contains(msg.sender)) {\\n            tryToJoinActiveSet(\\n                msg.sender,\\n                delegators[msg.sender].delegatedAmount,\\n                currentRound.add(1),\\n                _newPosPrev,\\n                _newPosNext\\n            );\\n        }\\n\\n        emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare);\\n    }\\n\\n    /**\\n     * @notice Delegates stake \\\"on behalf of\\\" another address towards a specific address\\n     * and updates the transcoder pool using optional list hints if needed\\n     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint\\n     * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.\\n     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the\\n     * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.\\n     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\\n     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\\n     * @param _amount The amount of tokens to stake.\\n     * @param _owner The address of the owner of the bond\\n     * @param _to The address of the transcoder to stake towards\\n     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate\\n     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate\\n     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate\\n     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate\\n     */\\n    function bondForWithHint(\\n        uint256 _amount,\\n        address _owner,\\n        address _to,\\n        address _oldDelegateNewPosPrev,\\n        address _oldDelegateNewPosNext,\\n        address _currDelegateNewPosPrev,\\n        address _currDelegateNewPosNext\\n    ) public whenSystemNotPaused currentRoundInitialized {\\n        // the `autoClaimEarnings` modifier has been replaced with its internal function as a `Stack too deep` error work-around\\n        _autoClaimEarnings(_owner);\\n        Delegator storage del = delegators[_owner];\\n\\n        uint256 currentRound = roundsManager().currentRound();\\n        // Amount to delegate\\n        uint256 delegationAmount = _amount;\\n        // Current delegate\\n        address currentDelegate = del.delegateAddress;\\n        // Current bonded amount\\n        uint256 currentBondedAmount = del.bondedAmount;\\n\\n        if (delegatorStatus(_owner) == DelegatorStatus.Unbonded) {\\n            // New delegate\\n            // Set start round\\n            // Don't set start round if delegator is in pending state because the start round would not change\\n            del.startRound = currentRound.add(1);\\n            // Unbonded state = no existing delegate and no bonded stake\\n            // Thus, delegation amount = provided amount\\n        } else if (currentBondedAmount > 0 && currentDelegate != _to) {\\n            // Prevents third-party caller to change the delegate of a delegator\\n            require(msg.sender == _owner || msg.sender == l2Migrator(), \\\"INVALID_CALLER\\\");\\n            // A registered transcoder cannot delegate its bonded stake toward another address\\n            // because it can only be delegated toward itself\\n            // In the future, if delegation towards another registered transcoder as an already\\n            // registered transcoder becomes useful (i.e. for transitive delegation), this restriction\\n            // could be removed\\n            require(!isRegisteredTranscoder(_owner), \\\"registered transcoders can't delegate towards other addresses\\\");\\n            // Changing delegate\\n            // Set start round\\n            del.startRound = currentRound.add(1);\\n            // Update amount to delegate with previous delegation amount\\n            delegationAmount = delegationAmount.add(currentBondedAmount);\\n\\n            decreaseTotalStake(currentDelegate, currentBondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);\\n        }\\n\\n        {\\n            Transcoder storage newDelegate = transcoders[_to];\\n            EarningsPool.Data storage currPool = newDelegate.earningsPoolPerRound[currentRound];\\n            if (currPool.cumulativeRewardFactor == 0) {\\n                currPool.cumulativeRewardFactor = cumulativeFactorsPool(newDelegate, newDelegate.lastRewardRound)\\n                    .cumulativeRewardFactor;\\n            }\\n            if (currPool.cumulativeFeeFactor == 0) {\\n                currPool.cumulativeFeeFactor = cumulativeFactorsPool(newDelegate, newDelegate.lastFeeRound)\\n                    .cumulativeFeeFactor;\\n            }\\n        }\\n\\n        // cannot delegate to someone without having bonded stake\\n        require(delegationAmount > 0, \\\"delegation amount must be greater than 0\\\");\\n        // Update delegate\\n        del.delegateAddress = _to;\\n        // Update bonded amount\\n        del.bondedAmount = currentBondedAmount.add(_amount);\\n\\n        increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);\\n\\n        if (_amount > 0) {\\n            // Transfer the LPT to the Minter\\n            livepeerToken().transferFrom(msg.sender, address(minter()), _amount);\\n        }\\n\\n        emit Bond(_to, currentDelegate, _owner, _amount, del.bondedAmount);\\n\\n        // the `autoCheckpoint` modifier has been replaced with its internal function as a `Stack too deep` error work-around\\n        checkpointBondingState(_owner, del, transcoders[_to]);\\n    }\\n\\n    /**\\n     * @notice Checkpoints a delegator state after changes, to be used for historical voting power calculations in\\n     * on-chain governor logic.\\n     */\\n    function checkpointBondingState(\\n        address _owner,\\n        Delegator storage _delegator,\\n        Transcoder storage _transcoder\\n    ) internal {\\n        // start round refers to the round where the checkpointed stake will be active. The actual `startRound` value\\n        // in the delegators doesn't get updated on bond or claim earnings though, so we use currentRound() + 1\\n        // which is the only guaranteed round where the currently stored stake will be active.\\n        uint256 startRound = roundsManager().currentRound() + 1;\\n        bondingVotes().checkpointBondingState(\\n            _owner,\\n            startRound,\\n            _delegator.bondedAmount,\\n            _delegator.delegateAddress,\\n            _delegator.delegatedAmount,\\n            _delegator.lastClaimRound,\\n            _transcoder.lastRewardRound\\n        );\\n    }\\n\\n    /**\\n     * @notice Checkpoints the bonding state for a given account.\\n     * @dev This is to allow checkpointing an account that has an inconsistent checkpoint with its current state.\\n     * Implemented as a deploy utility to checkpoint the existing state when deploying the BondingVotes contract.\\n     * @param _account The account to initialize the bonding checkpoint for\\n     */\\n    function checkpointBondingState(address _account) public {\\n        checkpointBondingState(_account, delegators[_account], transcoders[_account]);\\n    }\\n\\n    /**\\n     * @notice Delegates stake towards a specific address and updates the transcoder pool using optional list hints if needed\\n     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint\\n     * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.\\n     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the\\n     * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.\\n     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\\n     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\\n     * @param _amount The amount of tokens to stake.\\n     * @param _to The address of the transcoder to stake towards\\n     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate\\n     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate\\n     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate\\n     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate\\n     */\\n    function bondWithHint(\\n        uint256 _amount,\\n        address _to,\\n        address _oldDelegateNewPosPrev,\\n        address _oldDelegateNewPosNext,\\n        address _currDelegateNewPosPrev,\\n        address _currDelegateNewPosNext\\n    ) public {\\n        bondForWithHint(\\n            _amount,\\n            msg.sender,\\n            _to,\\n            _oldDelegateNewPosPrev,\\n            _oldDelegateNewPosNext,\\n            _currDelegateNewPosPrev,\\n            _currDelegateNewPosNext\\n        );\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of a bond to a new delegator using optional hints if needed\\n     *\\n     * If the receiver is already bonded to a different delegate than the bond owner then the stake goes\\n     * to the receiver's delegate otherwise the receiver's delegate is set as the owner's delegate\\n     *\\n     * @dev If the original delegate is in the transcoder pool, the caller can provide an optional hint for the\\n     * insertion position of the delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.\\n     * If the target delegate is in the transcoder pool, the caller can provide an optional hint for the\\n     * insertion position of the delegate via the `_newDelegateNewPosPrev` and `_newDelegateNewPosNext` params.\\n     *\\n     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\\n     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\\n     * @param _delegator Receiver of the bond\\n     * @param _amount Portion of the bond to transfer to receiver\\n     * @param _oldDelegateNewPosPrev Address of previous transcoder in pool if the delegate remains in the pool\\n     * @param _oldDelegateNewPosNext Address of next transcoder in pool if the delegate remains in the pool\\n     * @param _newDelegateNewPosPrev Address of previous transcoder in pool if the delegate is in the pool\\n     * @param _newDelegateNewPosNext Address of next transcoder in pool if the delegate is in the pool\\n     */\\n    function transferBond(\\n        address _delegator,\\n        uint256 _amount,\\n        address _oldDelegateNewPosPrev,\\n        address _oldDelegateNewPosNext,\\n        address _newDelegateNewPosPrev,\\n        address _newDelegateNewPosNext\\n    ) public whenSystemNotPaused currentRoundInitialized {\\n        // the `autoClaimEarnings` modifier has been replaced with its internal function as a `Stack too deep` error work-around\\n        _autoClaimEarnings(msg.sender);\\n        Delegator storage oldDel = delegators[msg.sender];\\n        // Cache delegate address of caller before unbondWithHint because\\n        // if unbondWithHint is for a full unbond the caller's delegate address will be set to null\\n        address oldDelDelegate = oldDel.delegateAddress;\\n\\n        unbondWithHint(_amount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);\\n\\n        Delegator storage newDel = delegators[_delegator];\\n\\n        uint256 oldDelUnbondingLockId = oldDel.nextUnbondingLockId.sub(1);\\n        uint256 withdrawRound = oldDel.unbondingLocks[oldDelUnbondingLockId].withdrawRound;\\n\\n        // Burn lock for current owner\\n        delete oldDel.unbondingLocks[oldDelUnbondingLockId];\\n\\n        // Create lock for new owner\\n        uint256 newDelUnbondingLockId = newDel.nextUnbondingLockId;\\n\\n        newDel.unbondingLocks[newDelUnbondingLockId] = UnbondingLock({ amount: _amount, withdrawRound: withdrawRound });\\n        newDel.nextUnbondingLockId = newDel.nextUnbondingLockId.add(1);\\n\\n        emit TransferBond(msg.sender, _delegator, oldDelUnbondingLockId, newDelUnbondingLockId, _amount);\\n\\n        // Claim earnings for receiver before processing unbonding lock\\n        uint256 currentRound = roundsManager().currentRound();\\n        uint256 lastClaimRound = newDel.lastClaimRound;\\n        if (lastClaimRound < currentRound) {\\n            updateDelegatorWithEarnings(_delegator, currentRound, lastClaimRound);\\n        }\\n\\n        // Rebond lock for new owner\\n        if (newDel.delegateAddress == address(0) && newDel.bondedAmount == 0) {\\n            newDel.delegateAddress = oldDelDelegate;\\n        }\\n\\n        // Move to Pending state if receiver is currently in Unbonded state\\n        if (delegatorStatus(_delegator) == DelegatorStatus.Unbonded) {\\n            newDel.startRound = currentRound.add(1);\\n        }\\n\\n        // Process rebond using unbonding lock\\n        processRebond(_delegator, newDelUnbondingLockId, _newDelegateNewPosPrev, _newDelegateNewPosNext);\\n    }\\n\\n    /**\\n     * @notice Unbond an amount of the delegator's bonded stake and updates the transcoder pool using an optional list hint if needed\\n     * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the\\n     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints\\n     * @param _amount Amount of tokens to unbond\\n     * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool\\n     * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool\\n     */\\n    function unbondWithHint(\\n        uint256 _amount,\\n        address _newPosPrev,\\n        address _newPosNext\\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings(msg.sender) autoCheckpoint(msg.sender) {\\n        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, \\\"caller must be bonded\\\");\\n\\n        Delegator storage del = delegators[msg.sender];\\n\\n        require(_amount > 0, \\\"unbond amount must be greater than 0\\\");\\n        require(_amount <= del.bondedAmount, \\\"amount is greater than bonded amount\\\");\\n\\n        address currentDelegate = del.delegateAddress;\\n        uint256 currentRound = roundsManager().currentRound();\\n        uint256 withdrawRound = currentRound.add(unbondingPeriod);\\n        uint256 unbondingLockId = del.nextUnbondingLockId;\\n\\n        // Create new unbonding lock\\n        del.unbondingLocks[unbondingLockId] = UnbondingLock({ amount: _amount, withdrawRound: withdrawRound });\\n        // Increment ID for next unbonding lock\\n        del.nextUnbondingLockId = unbondingLockId.add(1);\\n        // Decrease delegator's bonded amount\\n        del.bondedAmount = del.bondedAmount.sub(_amount);\\n\\n        if (del.bondedAmount == 0) {\\n            // Delegator no longer delegated to anyone if it does not have a bonded amount\\n            del.delegateAddress = address(0);\\n            // Delegator does not have a start round if it is no longer delegated to anyone\\n            del.startRound = 0;\\n\\n            if (transcoderPool.contains(msg.sender)) {\\n                resignTranscoder(msg.sender);\\n            }\\n        }\\n\\n        // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount\\n        decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);\\n\\n        emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound);\\n    }\\n\\n    /**\\n     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status and updates\\n     * the transcoder pool using an optional list hint if needed\\n     * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the\\n     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints\\n     * @param _unbondingLockId ID of unbonding lock to rebond with\\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool\\n     * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool\\n     */\\n    function rebondWithHint(\\n        uint256 _unbondingLockId,\\n        address _newPosPrev,\\n        address _newPosNext\\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings(msg.sender) {\\n        require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, \\\"caller must be bonded\\\");\\n\\n        // Process rebond using unbonding lock\\n        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);\\n    }\\n\\n    /**\\n     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using\\n     * an optional list hint if needed\\n     * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the\\n     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\\n     * @param _to Address of delegate\\n     * @param _unbondingLockId ID of unbonding lock to rebond with\\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool\\n     * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool\\n     */\\n    function rebondFromUnbondedWithHint(\\n        address _to,\\n        uint256 _unbondingLockId,\\n        address _newPosPrev,\\n        address _newPosNext\\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings(msg.sender) {\\n        require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, \\\"caller must be unbonded\\\");\\n\\n        // Set delegator's start round and transition into Pending state\\n        delegators[msg.sender].startRound = roundsManager().currentRound().add(1);\\n        // Set delegator's delegate\\n        delegators[msg.sender].delegateAddress = _to;\\n        // Process rebond using unbonding lock\\n        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);\\n    }\\n\\n    /**\\n     * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed\\n     * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the\\n     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\\n     * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool\\n     * @param _newPosNext Address of next transcoder in pool if the caller is in the pool\\n     */\\n    function rewardWithHint(address _newPosPrev, address _newPosNext)\\n        public\\n        whenSystemNotPaused\\n        currentRoundInitialized\\n        autoCheckpoint(msg.sender)\\n    {\\n        uint256 currentRound = roundsManager().currentRound();\\n\\n        require(isActiveTranscoder(msg.sender), \\\"caller must be an active transcoder\\\");\\n        require(\\n            transcoders[msg.sender].lastRewardRound != currentRound,\\n            \\\"caller has already called reward for the current round\\\"\\n        );\\n\\n        Transcoder storage t = transcoders[msg.sender];\\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\\n\\n        // Set last round that transcoder called reward\\n        earningsPool.setCommission(t.rewardCut, t.feeShare);\\n\\n        // If transcoder didn't receive stake updates during the previous round and hasn't called reward for > 1 round\\n        // the 'totalStake' on its 'EarningsPool' for the current round wouldn't be initialized\\n        // Thus we sync the the transcoder's stake to when it was last updated\\n        // 'updateTrancoderWithRewards()' will set the update round to 'currentRound +1' so this synchronization shouldn't occur frequently\\n        uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\\n        if (lastUpdateRound < currentRound) {\\n            earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\\n        }\\n\\n        if (treasuryBalanceCeiling > 0) {\\n            uint256 treasuryBalance = livepeerToken().balanceOf(treasury());\\n            if (treasuryBalance >= treasuryBalanceCeiling && nextRoundTreasuryRewardCutRate > 0) {\\n                // halt treasury contributions until the cut rate param is updated again\\n                _setTreasuryRewardCutRate(0);\\n            }\\n        }\\n\\n        // Create reward based on active transcoder's stake relative to the total active stake\\n        // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake\\n        IMinter mtr = minter();\\n        uint256 totalRewardTokens = mtr.createReward(earningsPool.totalStake, currentRoundTotalActiveStake);\\n        uint256 treasuryRewards = PreciseMathUtils.percOf(totalRewardTokens, treasuryRewardCutRate);\\n        if (treasuryRewards > 0) {\\n            address trsry = treasury();\\n\\n            mtr.trustedTransferTokens(trsry, treasuryRewards);\\n\\n            emit TreasuryReward(msg.sender, trsry, treasuryRewards);\\n        }\\n\\n        uint256 transcoderRewards = totalRewardTokens.sub(treasuryRewards);\\n\\n        updateTranscoderWithRewards(msg.sender, transcoderRewards, currentRound, _newPosPrev, _newPosNext);\\n\\n        // Set last round that transcoder called reward\\n        t.lastRewardRound = currentRound;\\n\\n        emit Reward(msg.sender, transcoderRewards);\\n    }\\n\\n    /**\\n     * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round\\n     * @param _delegator Address of delegator\\n     * @param _endRound The last round to compute pending stake from\\n     * @return Pending bonded stake for '_delegator' since last claiming rewards\\n     */\\n    function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {\\n        // Silence unused param compiler warning\\n        _endRound;\\n\\n        uint256 endRound = roundsManager().currentRound();\\n        (uint256 stake, ) = pendingStakeAndFees(_delegator, endRound);\\n        return stake;\\n    }\\n\\n    /**\\n     * @notice Returns pending fees for a delegator from its lastClaimRound through an end round\\n     * @param _delegator Address of delegator\\n     * @param _endRound The last round to compute pending fees from\\n     * @return Pending fees for '_delegator' since last claiming fees\\n     */\\n    function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {\\n        // Silence unused param compiler warning\\n        _endRound;\\n\\n        uint256 endRound = roundsManager().currentRound();\\n        (, uint256 fees) = pendingStakeAndFees(_delegator, endRound);\\n        return fees;\\n    }\\n\\n    /**\\n     * @notice Returns total bonded stake for a transcoder\\n     * @param _transcoder Address of transcoder\\n     * @return total bonded stake for a delegator\\n     */\\n    function transcoderTotalStake(address _transcoder) public view returns (uint256) {\\n        return delegators[_transcoder].delegatedAmount;\\n    }\\n\\n    /**\\n     * @notice Computes transcoder status\\n     * @param _transcoder Address of transcoder\\n     * @return registered or not registered transcoder status\\n     */\\n    function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {\\n        if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;\\n        return TranscoderStatus.NotRegistered;\\n    }\\n\\n    /**\\n     * @notice Computes delegator status\\n     * @param _delegator Address of delegator\\n     * @return bonded, unbonded or pending delegator status\\n     */\\n    function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {\\n        Delegator storage del = delegators[_delegator];\\n\\n        if (del.bondedAmount == 0) {\\n            // Delegator unbonded all its tokens\\n            return DelegatorStatus.Unbonded;\\n        } else if (del.startRound > roundsManager().currentRound()) {\\n            // Delegator round start is in the future\\n            return DelegatorStatus.Pending;\\n        } else {\\n            // Delegator round start is now or in the past\\n            // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which\\n            // would trigger the first if clause\\n            return DelegatorStatus.Bonded;\\n        }\\n    }\\n\\n    /**\\n     * @notice Return transcoder information\\n     * @param _transcoder Address of transcoder\\n     * @return lastRewardRound Trancoder's last reward round\\n     * @return rewardCut Transcoder's reward cut\\n     * @return feeShare Transcoder's fee share\\n     * @return lastActiveStakeUpdateRound Round in which transcoder's stake was last updated while active\\n     * @return activationRound Round in which transcoder became active\\n     * @return deactivationRound Round in which transcoder will no longer be active\\n     * @return activeCumulativeRewards Transcoder's cumulative rewards that are currently active\\n     * @return cumulativeRewards Transcoder's cumulative rewards (earned via its active staked rewards and its reward cut)\\n     * @return cumulativeFees Transcoder's cumulative fees (earned via its active staked rewards and its fee share)\\n     * @return lastFeeRound Latest round that the transcoder received fees\\n     */\\n    function getTranscoder(address _transcoder)\\n        public\\n        view\\n        returns (\\n            uint256 lastRewardRound,\\n            uint256 rewardCut,\\n            uint256 feeShare,\\n            uint256 lastActiveStakeUpdateRound,\\n            uint256 activationRound,\\n            uint256 deactivationRound,\\n            uint256 activeCumulativeRewards,\\n            uint256 cumulativeRewards,\\n            uint256 cumulativeFees,\\n            uint256 lastFeeRound\\n        )\\n    {\\n        Transcoder storage t = transcoders[_transcoder];\\n\\n        lastRewardRound = t.lastRewardRound;\\n        rewardCut = t.rewardCut;\\n        feeShare = t.feeShare;\\n        lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;\\n        activationRound = t.activationRound;\\n        deactivationRound = t.deactivationRound;\\n        activeCumulativeRewards = t.activeCumulativeRewards;\\n        cumulativeRewards = t.cumulativeRewards;\\n        cumulativeFees = t.cumulativeFees;\\n        lastFeeRound = t.lastFeeRound;\\n    }\\n\\n    /**\\n     * @notice Return transcoder's earnings pool for a given round\\n     * @param _transcoder Address of transcoder\\n     * @param _round Round number\\n     * @return totalStake Transcoder's total stake in '_round'\\n     * @return transcoderRewardCut Transcoder's reward cut for '_round'\\n     * @return transcoderFeeShare Transcoder's fee share for '_round'\\n     * @return cumulativeRewardFactor The cumulative reward factor for delegator rewards calculation (only used after LIP-36)\\n     * @return cumulativeFeeFactor The cumulative fee factor for delegator fees calculation (only used after LIP-36)\\n     */\\n    function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)\\n        public\\n        view\\n        returns (\\n            uint256 totalStake,\\n            uint256 transcoderRewardCut,\\n            uint256 transcoderFeeShare,\\n            uint256 cumulativeRewardFactor,\\n            uint256 cumulativeFeeFactor\\n        )\\n    {\\n        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];\\n\\n        totalStake = earningsPool.totalStake;\\n        transcoderRewardCut = earningsPool.transcoderRewardCut;\\n        transcoderFeeShare = earningsPool.transcoderFeeShare;\\n        cumulativeRewardFactor = earningsPool.cumulativeRewardFactor;\\n        cumulativeFeeFactor = earningsPool.cumulativeFeeFactor;\\n    }\\n\\n    /**\\n     * @notice Return delegator info\\n     * @param _delegator Address of delegator\\n     * @return bondedAmount total amount bonded by '_delegator'\\n     * @return fees amount of fees collected by '_delegator'\\n     * @return delegateAddress address '_delegator' has bonded to\\n     * @return delegatedAmount total amount delegated to '_delegator'\\n     * @return startRound round in which bond for '_delegator' became effective\\n     * @return lastClaimRound round for which '_delegator' has last claimed earnings\\n     * @return nextUnbondingLockId ID for the next unbonding lock created for '_delegator'\\n     */\\n    function getDelegator(address _delegator)\\n        public\\n        view\\n        returns (\\n            uint256 bondedAmount,\\n            uint256 fees,\\n            address delegateAddress,\\n            uint256 delegatedAmount,\\n            uint256 startRound,\\n            uint256 lastClaimRound,\\n            uint256 nextUnbondingLockId\\n        )\\n    {\\n        Delegator storage del = delegators[_delegator];\\n\\n        bondedAmount = del.bondedAmount;\\n        fees = del.fees;\\n        delegateAddress = del.delegateAddress;\\n        delegatedAmount = del.delegatedAmount;\\n        startRound = del.startRound;\\n        lastClaimRound = del.lastClaimRound;\\n        nextUnbondingLockId = del.nextUnbondingLockId;\\n    }\\n\\n    /**\\n     * @notice Return delegator's unbonding lock info\\n     * @param _delegator Address of delegator\\n     * @param _unbondingLockId ID of unbonding lock\\n     * @return amount of stake locked up by unbonding lock\\n     * @return withdrawRound round in which 'amount' becomes available for withdrawal\\n     */\\n    function getDelegatorUnbondingLock(address _delegator, uint256 _unbondingLockId)\\n        public\\n        view\\n        returns (uint256 amount, uint256 withdrawRound)\\n    {\\n        UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];\\n\\n        return (lock.amount, lock.withdrawRound);\\n    }\\n\\n    /**\\n     * @notice Returns max size of transcoder pool\\n     * @return transcoder pool max size\\n     */\\n    function getTranscoderPoolMaxSize() public view returns (uint256) {\\n        return transcoderPool.getMaxSize();\\n    }\\n\\n    /**\\n     * @notice Returns size of transcoder pool\\n     * @return transcoder pool current size\\n     */\\n    function getTranscoderPoolSize() public view returns (uint256) {\\n        return transcoderPool.getSize();\\n    }\\n\\n    /**\\n     * @notice Returns transcoder with most stake in pool\\n     * @return address for transcoder with highest stake in transcoder pool\\n     */\\n    function getFirstTranscoderInPool() public view returns (address) {\\n        return transcoderPool.getFirst();\\n    }\\n\\n    /**\\n     * @notice Returns next transcoder in pool for a given transcoder\\n     * @param _transcoder Address of a transcoder in the pool\\n     * @return address for the transcoder after '_transcoder' in transcoder pool\\n     */\\n    function getNextTranscoderInPool(address _transcoder) public view returns (address) {\\n        return transcoderPool.getNext(_transcoder);\\n    }\\n\\n    /**\\n     * @notice Return total bonded tokens\\n     * @return total active stake for the current round\\n     */\\n    function getTotalBonded() public view returns (uint256) {\\n        return currentRoundTotalActiveStake;\\n    }\\n\\n    /**\\n     * @notice Return whether a transcoder is active for the current round\\n     * @param _transcoder Transcoder address\\n     * @return true if transcoder is active\\n     */\\n    function isActiveTranscoder(address _transcoder) public view returns (bool) {\\n        Transcoder storage t = transcoders[_transcoder];\\n        uint256 currentRound = roundsManager().currentRound();\\n        return t.activationRound <= currentRound && currentRound < t.deactivationRound;\\n    }\\n\\n    /**\\n     * @notice Return whether a transcoder is registered\\n     * @param _transcoder Transcoder address\\n     * @return true if transcoder is self-bonded\\n     */\\n    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {\\n        Delegator storage d = delegators[_transcoder];\\n        return d.delegateAddress == _transcoder && d.bondedAmount > 0;\\n    }\\n\\n    /**\\n     * @notice Return whether an unbonding lock for a delegator is valid\\n     * @param _delegator Address of delegator\\n     * @param _unbondingLockId ID of unbonding lock\\n     * @return true if unbondingLock for ID has a non-zero withdraw round\\n     */\\n    function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {\\n        // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)\\n        return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0;\\n    }\\n\\n    /**\\n     * @notice Return an EarningsPool.Data struct with cumulative factors for a given round that are rescaled if needed\\n     * @param _transcoder Storage pointer to a transcoder struct\\n     * @param _round The round to fetch the cumulative factors for\\n     */\\n    function cumulativeFactorsPool(Transcoder storage _transcoder, uint256 _round)\\n        internal\\n        view\\n        returns (EarningsPool.Data memory pool)\\n    {\\n        pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_round].cumulativeRewardFactor;\\n        pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_round].cumulativeFeeFactor;\\n\\n        return pool;\\n    }\\n\\n    /**\\n     * @notice Return an EarningsPool.Data struct with the latest cumulative factors for a given round\\n     * @param _transcoder Storage pointer to a transcoder struct\\n     * @param _round The round to fetch the latest cumulative factors for\\n     * @return pool An EarningsPool.Data populated with the latest cumulative factors for _round\\n     */\\n    function latestCumulativeFactorsPool(Transcoder storage _transcoder, uint256 _round)\\n        internal\\n        view\\n        returns (EarningsPool.Data memory pool)\\n    {\\n        pool = cumulativeFactorsPool(_transcoder, _round);\\n\\n        uint256 lastRewardRound = _transcoder.lastRewardRound;\\n        // Only use the cumulativeRewardFactor for lastRewardRound if lastRewardRound is before _round\\n        if (pool.cumulativeRewardFactor == 0 && lastRewardRound < _round) {\\n            pool.cumulativeRewardFactor = cumulativeFactorsPool(_transcoder, lastRewardRound).cumulativeRewardFactor;\\n        }\\n\\n        uint256 lastFeeRound = _transcoder.lastFeeRound;\\n        // Only use the cumulativeFeeFactor for lastFeeRound if lastFeeRound is before _round\\n        if (pool.cumulativeFeeFactor == 0 && lastFeeRound < _round) {\\n            pool.cumulativeFeeFactor = cumulativeFactorsPool(_transcoder, lastFeeRound).cumulativeFeeFactor;\\n        }\\n\\n        return pool;\\n    }\\n\\n    /**\\n     * @notice Return a delegator's cumulative stake and fees using the LIP-36 earnings claiming algorithm\\n     * @param _transcoder Storage pointer to a transcoder struct for a delegator's delegate\\n     * @param _startRound The round for the start cumulative factors\\n     * @param _endRound The round for the end cumulative factors. Normally this is the current round as historical\\n     * lookup is only supported through BondingVotes\\n     * @param _stake The delegator's initial stake before including earned rewards\\n     * @param _fees The delegator's initial fees before including earned fees\\n     * @return cStake , cFees where cStake is the delegator's cumulative stake including earned rewards and cFees is the delegator's cumulative fees including earned fees\\n     */\\n    function delegatorCumulativeStakeAndFees(\\n        Transcoder storage _transcoder,\\n        uint256 _startRound,\\n        uint256 _endRound,\\n        uint256 _stake,\\n        uint256 _fees\\n    ) internal view returns (uint256 cStake, uint256 cFees) {\\n        // Fetch start cumulative factors\\n        EarningsPool.Data memory startPool = cumulativeFactorsPool(_transcoder, _startRound);\\n        // Fetch end cumulative factors\\n        EarningsPool.Data memory endPool = latestCumulativeFactorsPool(_transcoder, _endRound);\\n\\n        return EarningsPoolLIP36.delegatorCumulativeStakeAndFees(startPool, endPool, _stake, _fees);\\n    }\\n\\n    /**\\n     * @notice Return the pending stake and fees for a delegator\\n     * @param _delegator Address of a delegator\\n     * @param _endRound The last round to claim earnings for when calculating the pending stake and fees\\n     * @return stake , fees where stake is the delegator's pending stake and fees is the delegator's pending fees\\n     */\\n    function pendingStakeAndFees(address _delegator, uint256 _endRound)\\n        internal\\n        view\\n        returns (uint256 stake, uint256 fees)\\n    {\\n        Delegator storage del = delegators[_delegator];\\n        Transcoder storage t = transcoders[del.delegateAddress];\\n\\n        fees = del.fees;\\n        stake = del.bondedAmount;\\n\\n        uint256 startRound = del.lastClaimRound.add(1);\\n        address delegateAddr = del.delegateAddress;\\n        bool isTranscoder = _delegator == delegateAddr;\\n\\n        // Make sure there is a round to claim i.e. end round - (start round - 1) > 0\\n        if (startRound <= _endRound) {\\n            (stake, fees) = delegatorCumulativeStakeAndFees(t, startRound.sub(1), _endRound, stake, fees);\\n        }\\n        // cumulativeRewards and cumulativeFees will track *all* rewards/fees earned by the transcoder\\n        // so it is important that this is only executed with the end round as the current round or else\\n        // the returned stake and fees will reflect rewards/fees earned in the future relative to the end round\\n        if (isTranscoder) {\\n            stake = stake.add(t.cumulativeRewards);\\n            fees = fees.add(t.cumulativeFees);\\n        }\\n\\n        return (stake, fees);\\n    }\\n\\n    /**\\n     * @dev Increase the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'\\n     * @param _delegate The delegate to increase the stake for\\n     * @param _amount The amount to increase the stake for '_delegate' by\\n     */\\n    function increaseTotalStake(\\n        address _delegate,\\n        uint256 _amount,\\n        address _newPosPrev,\\n        address _newPosNext\\n    ) internal autoCheckpoint(_delegate) {\\n        return increaseTotalStakeUncheckpointed(_delegate, _amount, _newPosPrev, _newPosNext);\\n    }\\n\\n    /**\\n     * @dev Implementation of increaseTotalStake that does not checkpoint the caller, to be used by functions that\\n     * guarantee the checkpointing themselves.\\n     */\\n    function increaseTotalStakeUncheckpointed(\\n        address _delegate,\\n        uint256 _amount,\\n        address _newPosPrev,\\n        address _newPosNext\\n    ) internal {\\n        Transcoder storage t = transcoders[_delegate];\\n\\n        uint256 currStake = transcoderTotalStake(_delegate);\\n        uint256 newStake = currStake.add(_amount);\\n\\n        if (isRegisteredTranscoder(_delegate)) {\\n            uint256 currRound = roundsManager().currentRound();\\n            uint256 nextRound = currRound.add(1);\\n\\n            // If the transcoder is already in the active set update its stake and return\\n            if (transcoderPool.contains(_delegate)) {\\n                transcoderPool.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);\\n                nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);\\n\\n                // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound\\n                // because it is updated every time lastActiveStakeUpdateRound is updated\\n                // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()\\n                // and updateTranscoderWithFees() when lastActiveStakeUpdateRound > currentRound\\n                if (t.lastActiveStakeUpdateRound < currRound) {\\n                    t.earningsPoolPerRound[currRound].setStake(currStake);\\n                }\\n\\n                t.earningsPoolPerRound[nextRound].setStake(newStake);\\n                t.lastActiveStakeUpdateRound = nextRound;\\n            } else {\\n                // Check if the transcoder is eligible to join the active set in the update round\\n                tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);\\n            }\\n        }\\n\\n        // Increase delegate's delegated amount\\n        delegators[_delegate].delegatedAmount = newStake;\\n    }\\n\\n    /**\\n     * @dev Decrease the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'\\n     * @param _delegate The transcoder to decrease the stake for\\n     * @param _amount The amount to decrease the stake for '_delegate' by\\n     */\\n    function decreaseTotalStake(\\n        address _delegate,\\n        uint256 _amount,\\n        address _newPosPrev,\\n        address _newPosNext\\n    ) internal autoCheckpoint(_delegate) {\\n        Transcoder storage t = transcoders[_delegate];\\n\\n        uint256 currStake = transcoderTotalStake(_delegate);\\n        uint256 newStake = currStake.sub(_amount);\\n\\n        if (transcoderPool.contains(_delegate)) {\\n            uint256 currRound = roundsManager().currentRound();\\n            uint256 nextRound = currRound.add(1);\\n\\n            transcoderPool.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);\\n            nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);\\n\\n            // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound\\n            // because it is updated every time lastActiveStakeUpdateRound is updated\\n            // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()\\n            // and updateTranscoderWithFees() when lastActiveStakeUpdateRound > currentRound\\n            if (t.lastActiveStakeUpdateRound < currRound) {\\n                t.earningsPoolPerRound[currRound].setStake(currStake);\\n            }\\n\\n            t.lastActiveStakeUpdateRound = nextRound;\\n            t.earningsPoolPerRound[nextRound].setStake(newStake);\\n        }\\n\\n        // Decrease old delegate's delegated amount\\n        delegators[_delegate].delegatedAmount = newStake;\\n    }\\n\\n    /**\\n     * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full\\n     * @param _transcoder The transcoder to insert into the transcoder pool\\n     * @param _totalStake The total stake for '_transcoder'\\n     * @param _activationRound The round in which the transcoder should become active\\n     */\\n    function tryToJoinActiveSet(\\n        address _transcoder,\\n        uint256 _totalStake,\\n        uint256 _activationRound,\\n        address _newPosPrev,\\n        address _newPosNext\\n    ) internal {\\n        uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;\\n\\n        if (transcoderPool.isFull()) {\\n            address lastTranscoder = transcoderPool.getLast();\\n            uint256 lastStake = transcoderTotalStake(lastTranscoder);\\n\\n            // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool\\n            // then the transcoder is unable to join the active set for the next round\\n            if (_totalStake <= lastStake) {\\n                return;\\n            }\\n\\n            // Evict the least stake transcoder from the active set for the next round\\n            // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)\\n            // There should be no side-effects as long as the value is properly updated on stake updates\\n            // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as\\n            // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.\\n            transcoderPool.remove(lastTranscoder);\\n            transcoders[lastTranscoder].deactivationRound = _activationRound;\\n            pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);\\n\\n            emit TranscoderDeactivated(lastTranscoder, _activationRound);\\n        }\\n\\n        transcoderPool.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);\\n        pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);\\n        Transcoder storage t = transcoders[_transcoder];\\n        t.lastActiveStakeUpdateRound = _activationRound;\\n        t.activationRound = _activationRound;\\n        t.deactivationRound = MAX_FUTURE_ROUND;\\n        t.earningsPoolPerRound[_activationRound].setStake(_totalStake);\\n        nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;\\n        emit TranscoderActivated(_transcoder, _activationRound);\\n    }\\n\\n    /**\\n     * @dev Remove a transcoder from the pool and deactivate it\\n     */\\n    function resignTranscoder(address _transcoder) internal {\\n        // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)\\n        // There should be no side-effects as long as the value is properly updated on stake updates\\n        // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as\\n        // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.\\n        transcoderPool.remove(_transcoder);\\n        nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));\\n        uint256 deactivationRound = roundsManager().currentRound().add(1);\\n        transcoders[_transcoder].deactivationRound = deactivationRound;\\n        emit TranscoderDeactivated(_transcoder, deactivationRound);\\n    }\\n\\n    /**\\n     * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.\\n     * See SortedDoublyLL.sol for details on list hints. This function updates the transcoder state but does not\\n     * checkpoint it as it assumes the caller will ensure that.\\n     * @param _transcoder Address of transcoder\\n     * @param _rewards Amount of rewards\\n     * @param _round Round that transcoder is updated\\n     * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool\\n     * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool\\n     */\\n    function updateTranscoderWithRewards(\\n        address _transcoder,\\n        uint256 _rewards,\\n        uint256 _round,\\n        address _newPosPrev,\\n        address _newPosNext\\n    ) internal {\\n        Transcoder storage t = transcoders[_transcoder];\\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];\\n        EarningsPool.Data memory prevEarningsPool = cumulativeFactorsPool(t, t.lastRewardRound);\\n\\n        t.activeCumulativeRewards = t.cumulativeRewards;\\n\\n        uint256 transcoderCommissionRewards = MathUtils.percOf(_rewards, earningsPool.transcoderRewardCut);\\n        uint256 delegatorsRewards = _rewards.sub(transcoderCommissionRewards);\\n        // Calculate the rewards earned by the transcoder's earned rewards\\n        uint256 transcoderRewardStakeRewards = PreciseMathUtils.percOf(\\n            delegatorsRewards,\\n            t.activeCumulativeRewards,\\n            earningsPool.totalStake\\n        );\\n        // Track rewards earned by the transcoder based on its earned rewards and rewardCut\\n        t.cumulativeRewards = t.cumulativeRewards.add(transcoderRewardStakeRewards).add(transcoderCommissionRewards);\\n        // Update cumulative reward factor with new rewards\\n        // The cumulativeRewardFactor is used to calculate rewards for all delegators including the transcoder (self-delegated)\\n        // Note that delegatorsRewards includes transcoderRewardStakeRewards, but no delegator will claim that amount using\\n        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeRewards field\\n        earningsPool.updateCumulativeRewardFactor(prevEarningsPool, delegatorsRewards);\\n        // Update transcoder's total stake with rewards\\n        increaseTotalStakeUncheckpointed(_transcoder, _rewards, _newPosPrev, _newPosNext);\\n    }\\n\\n    /**\\n     * @dev Update a delegator with token pools shares from its lastClaimRound through a given round\\n     *\\n     * Notice that this function udpates the delegator storage but does not checkpoint its state. Since it is internal\\n     * it assumes the top-level caller will checkpoint it instead.\\n     * @param _delegator Delegator address\\n     * @param _endRound The last round for which to update a delegator's stake with earnings pool shares\\n     * @param _lastClaimRound The round for which a delegator has last claimed earnings\\n     */\\n    function updateDelegatorWithEarnings(\\n        address _delegator,\\n        uint256 _endRound,\\n        uint256 _lastClaimRound\\n    ) internal {\\n        Delegator storage del = delegators[_delegator];\\n        uint256 startRound = _lastClaimRound.add(1);\\n        uint256 currentBondedAmount = del.bondedAmount;\\n        uint256 currentFees = del.fees;\\n\\n        // Only will have earnings to claim if you have a delegate\\n        // If not delegated, skip the earnings claim process\\n        if (del.delegateAddress != address(0)) {\\n            (currentBondedAmount, currentFees) = pendingStakeAndFees(_delegator, _endRound);\\n\\n            // Check whether the endEarningsPool is initialised\\n            // If it is not initialised set it's cumulative factors so that they can be used when a delegator\\n            // next claims earnings as the start cumulative factors (see delegatorCumulativeStakeAndFees())\\n            Transcoder storage t = transcoders[del.delegateAddress];\\n            EarningsPool.Data storage endEarningsPool = t.earningsPoolPerRound[_endRound];\\n            if (endEarningsPool.cumulativeRewardFactor == 0) {\\n                uint256 lastRewardRound = t.lastRewardRound;\\n                if (lastRewardRound < _endRound) {\\n                    endEarningsPool.cumulativeRewardFactor = cumulativeFactorsPool(t, lastRewardRound)\\n                        .cumulativeRewardFactor;\\n                }\\n            }\\n            if (endEarningsPool.cumulativeFeeFactor == 0) {\\n                uint256 lastFeeRound = t.lastFeeRound;\\n                if (lastFeeRound < _endRound) {\\n                    endEarningsPool.cumulativeFeeFactor = cumulativeFactorsPool(t, lastFeeRound).cumulativeFeeFactor;\\n                }\\n            }\\n\\n            if (del.delegateAddress == _delegator) {\\n                t.cumulativeFees = 0;\\n                t.cumulativeRewards = 0;\\n                // activeCumulativeRewards is not cleared here because the next reward() call will set it to cumulativeRewards\\n            }\\n        }\\n\\n        emit EarningsClaimed(\\n            del.delegateAddress,\\n            _delegator,\\n            currentBondedAmount.sub(del.bondedAmount),\\n            currentFees.sub(del.fees),\\n            startRound,\\n            _endRound\\n        );\\n\\n        del.lastClaimRound = _endRound;\\n        // Rewards are bonded by default\\n        del.bondedAmount = currentBondedAmount;\\n        del.fees = currentFees;\\n    }\\n\\n    /**\\n     * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional\\n     * list hint if needed. See SortedDoublyLL.sol for details on list hints\\n     * @param _delegator Address of delegator\\n     * @param _unbondingLockId ID of unbonding lock to rebond with\\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool\\n     * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool\\n     */\\n    function processRebond(\\n        address _delegator,\\n        uint256 _unbondingLockId,\\n        address _newPosPrev,\\n        address _newPosNext\\n    ) internal autoCheckpoint(_delegator) {\\n        Delegator storage del = delegators[_delegator];\\n        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\\n\\n        require(isValidUnbondingLock(_delegator, _unbondingLockId), \\\"invalid unbonding lock ID\\\");\\n\\n        uint256 amount = lock.amount;\\n        // Increase delegator's bonded amount\\n        del.bondedAmount = del.bondedAmount.add(amount);\\n\\n        // Delete lock\\n        delete del.unbondingLocks[_unbondingLockId];\\n\\n        increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);\\n\\n        emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount);\\n    }\\n\\n    /**\\n     * @dev Return LivepeerToken interface\\n     * @return Livepeer token contract registered with Controller\\n     */\\n    function livepeerToken() internal view returns (ILivepeerToken) {\\n        return ILivepeerToken(controller.getContract(keccak256(\\\"LivepeerToken\\\")));\\n    }\\n\\n    /**\\n     * @dev Return Minter interface\\n     * @return Minter contract registered with Controller\\n     */\\n    function minter() internal view returns (IMinter) {\\n        return IMinter(controller.getContract(keccak256(\\\"Minter\\\")));\\n    }\\n\\n    /**\\n     * @dev Return Address of L2Migrator\\n     * @return l2Migrator contract address registered with Controller\\n     */\\n    function l2Migrator() internal view returns (address) {\\n        return controller.getContract(keccak256(\\\"L2Migrator\\\"));\\n    }\\n\\n    /**\\n     * @dev Return RoundsManager interface\\n     * @return RoundsManager contract registered with Controller\\n     */\\n    function roundsManager() internal view returns (IRoundsManager) {\\n        return IRoundsManager(controller.getContract(keccak256(\\\"RoundsManager\\\")));\\n    }\\n\\n    function treasury() internal view returns (address) {\\n        return controller.getContract(keccak256(\\\"Treasury\\\"));\\n    }\\n\\n    function bondingVotes() internal view returns (IBondingVotes) {\\n        return IBondingVotes(controller.getContract(keccak256(\\\"BondingVotes\\\")));\\n    }\\n\\n    function _onlyTicketBroker() internal view {\\n        require(msg.sender == controller.getContract(keccak256(\\\"TicketBroker\\\")), \\\"caller must be TicketBroker\\\");\\n    }\\n\\n    function _onlyRoundsManager() internal view {\\n        require(msg.sender == controller.getContract(keccak256(\\\"RoundsManager\\\")), \\\"caller must be RoundsManager\\\");\\n    }\\n\\n    function _onlyVerifier() internal view {\\n        require(msg.sender == controller.getContract(keccak256(\\\"Verifier\\\")), \\\"caller must be Verifier\\\");\\n    }\\n\\n    function _currentRoundInitialized() internal view {\\n        require(roundsManager().currentRoundInitialized(), \\\"current round is not initialized\\\");\\n    }\\n\\n    function _autoClaimEarnings(address _delegator) internal {\\n        uint256 currentRound = roundsManager().currentRound();\\n        uint256 lastClaimRound = delegators[_delegator].lastClaimRound;\\n        if (lastClaimRound < currentRound) {\\n            updateDelegatorWithEarnings(_delegator, currentRound, lastClaimRound);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6371f5b170ed9bce67337652c811aad06d349d40ee2a25d39fb97b6264d27198\",\"license\":\"MIT\"},\"contracts/bonding/BondingVotes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/Arrays.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport \\\"./libraries/EarningsPool.sol\\\";\\nimport \\\"./libraries/EarningsPoolLIP36.sol\\\";\\nimport \\\"./libraries/SortedArrays.sol\\\";\\n\\nimport \\\"../ManagerProxyTarget.sol\\\";\\nimport \\\"../IController.sol\\\";\\nimport \\\"../rounds/IRoundsManager.sol\\\";\\nimport \\\"./BondingManager.sol\\\";\\n\\n/**\\n * @title BondingVotes\\n * @dev Checkpointing logic for BondingManager state for historical stake calculations.\\n */\\ncontract BondingVotes is ManagerProxyTarget, IBondingVotes {\\n    using Arrays for uint256[];\\n    using SortedArrays for uint256[];\\n\\n    constructor(address _controller) Manager(_controller) {}\\n\\n    struct BondingCheckpoint {\\n        /**\\n         * @dev The amount of bonded tokens to another delegate as of the lastClaimRound.\\n         */\\n        uint256 bondedAmount;\\n        /**\\n         * @dev The address of the delegate the account is bonded to. In case of transcoders this is their own address.\\n         */\\n        address delegateAddress;\\n        /**\\n         * @dev The amount of tokens delegated from delegators to this account. This is only set for transcoders, which\\n         * have to self-delegate first and then have tokens bonded from other delegators.\\n         */\\n        uint256 delegatedAmount;\\n        /**\\n         * @dev The last round during which the delegator claimed its earnings. This pegs the value of bondedAmount for\\n         * rewards calculation in {EarningsPoolLIP36-delegatorCumulativeStakeAndFees}.\\n         */\\n        uint256 lastClaimRound;\\n        /**\\n         * @dev The last round during which the checkpointed account called {BondingManager-reward}. This is needed to\\n         * when calculating pending rewards for a delegator to this transcoder, to find the last earning pool available\\n         * for a given round. In that case we start from the delegator checkpoint and then fetch its delegate address\\n         * checkpoint as well to find the last earning pool.\\n         *\\n         * Notice that this is the only field that comes from the Transcoder struct in BondingManager, not Delegator.\\n         */\\n        uint256 lastRewardRound;\\n    }\\n\\n    /**\\n     * @dev Stores a list of checkpoints for an account, queryable and mapped by start round. To access the checkpoint\\n     * for a given round, find the checkpoint with the highest start round that is lower or equal to the queried round\\n     * ({SortedArrays-findLowerBound}) and then fetch the specific checkpoint on the data mapping.\\n     */\\n    struct BondingCheckpointsByRound {\\n        uint256[] startRounds;\\n        mapping(uint256 => BondingCheckpoint) data;\\n    }\\n\\n    /**\\n     * @dev Stores a list of checkpoints for the total active stake, queryable and mapped by round. Notce that\\n     * differently from bonding checkpoints, it's only accessible on the specific round. To access the checkpoint for a\\n     * given round, look for the checkpoint in the {data}} and if it's zero ensure the round was actually checkpointed on\\n     * the {rounds} array ({SortedArrays-findLowerBound}).\\n     */\\n    struct TotalActiveStakeByRound {\\n        uint256[] rounds;\\n        mapping(uint256 => uint256) data;\\n    }\\n\\n    /**\\n     * @dev Checkpoints by account (delegators and transcoders).\\n     */\\n    mapping(address => BondingCheckpointsByRound) private bondingCheckpoints;\\n    /**\\n     * @dev Total active stake checkpoints.\\n     */\\n    TotalActiveStakeByRound private totalStakeCheckpoints;\\n\\n    /**\\n     * @dev Modifier to ensure the sender is BondingManager\\n     */\\n    modifier onlyBondingManager() {\\n        _onlyBondingManager();\\n        _;\\n    }\\n\\n    // ERC-20 Metadata\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory) {\\n        return \\\"Livepeer Stake\\\";\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory) {\\n        return livepeerToken().symbol();\\n    }\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8) {\\n        return livepeerToken().decimals();\\n    }\\n\\n    // IVotes interface implementation.\\n    // These should not access any storage directly but proxy to the bonding state functions.\\n\\n    /**\\n     * @notice Clock is set to match the current round, which is the checkpointing\\n     *  method implemented here.\\n     */\\n    function clock() public view returns (uint48) {\\n        return SafeCast.toUint48(roundsManager().currentRound());\\n    }\\n\\n    /**\\n     * @notice Machine-readable description of the clock as specified in EIP-6372.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CLOCK_MODE() public pure returns (string memory) {\\n        return \\\"mode=livepeer_round\\\";\\n    }\\n\\n    /**\\n     * @notice Returns the current amount of votes that `_account` has.\\n     */\\n    function getVotes(address _account) external view returns (uint256) {\\n        return getPastVotes(_account, clock());\\n    }\\n\\n    /**\\n     * @notice Returns the amount of votes that `_account` had at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\\n     * @dev Keep in mind that since this function should return the votes at the end of the _round (or timepoint in OZ\\n     * terms), we need to fetch the bonding state at the next round instead. That because the bonding state reflects the\\n     * active stake in the current round, which is the snapshotted stake from the end of the previous round.\\n     */\\n    function getPastVotes(address _account, uint256 _round) public view returns (uint256) {\\n        (uint256 amount, ) = getBondingStateAt(_account, _round + 1);\\n        return amount;\\n    }\\n\\n    /**\\n     * @notice Returns the total supply of votes available at a specific round in the past.\\n     * @dev This value is the sum of all *active* stake, which is not necessarily the sum of all voting power.\\n     * Bonded stake that is not part of the top 100 active transcoder set is still given voting power, but is not\\n     * considered here.\\n     * @dev Keep in mind that since this function should return the votes at the end of the _round (or timepoint in OZ\\n     * terms), we need to fetch the total active stake at the next round instead. That because the active stake in the\\n     * current round is the snapshotted stake from the end of the previous round.\\n     */\\n    function getPastTotalSupply(uint256 _round) public view returns (uint256) {\\n        return getTotalActiveStakeAt(_round + 1);\\n    }\\n\\n    /**\\n     * @notice Returns the delegate that _account has chosen. This means the delegated transcoder address in case of\\n     * delegators, and the account's own address for transcoders (self-delegated).\\n     */\\n    function delegates(address _account) external view returns (address) {\\n        return delegatedAt(_account, clock());\\n    }\\n\\n    /**\\n     * @notice Returns the delegate that _account had chosen in a specific round in the past. See `delegates()` above\\n     * for more details.\\n     * @dev This is an addition to the IERC5805 interface to support our custom vote counting logic that allows\\n     * delegators to override their transcoders votes. See {GaovernorCountingOverridable-_handleVoteOverrides}.\\n     * @dev Keep in mind that since this function should return the delegate at the end of the _round (or timepoint in\\n     * OZ terms), we need to fetch the bonding state at the next round instead. That because the bonding state reflects\\n     * the active stake in the current round, which is the snapshotted stake from the end of the previous round.\\n     */\\n    function delegatedAt(address _account, uint256 _round) public view returns (address) {\\n        (, address delegateAddress) = getBondingStateAt(_account, _round + 1);\\n        return delegateAddress;\\n    }\\n\\n    /**\\n     * @notice Delegation through BondingVotes is not supported.\\n     */\\n    function delegate(address) external pure {\\n        revert MustCallBondingManager(\\\"bond\\\");\\n    }\\n\\n    /**\\n     * @notice Delegation through BondingVotes is not supported.\\n     */\\n    function delegateBySig(\\n        address,\\n        uint256,\\n        uint256,\\n        uint8,\\n        bytes32,\\n        bytes32\\n    ) external pure {\\n        revert MustCallBondingManager(\\\"bondFor\\\");\\n    }\\n\\n    // BondingManager checkpointing hooks\\n\\n    /**\\n     * @notice Called by the BondingManager when the bonding state of an account changes.\\n     * @dev Since we checkpoint \\\"delegator\\\" and \\\"transcoder\\\" states, this is called both for the delegator and for the\\n     * transcoder when any change is made to the bonds, including when rewards are calculated or claimed.\\n     * @param _account The account whose bonding state changed\\n     * @param _startRound The round from which the bonding state will be active. This is normally the next round.\\n     * @param _bondedAmount From {BondingManager-Delegator-bondedAmount}\\n     * @param _delegateAddress From {BondingManager-Delegator-delegateAddress}\\n     * @param _delegatedAmount From {BondingManager-Transcoder-delegatedAmount}\\n     * @param _lastClaimRound From {BondingManager-Delegator-lastClaimRound}\\n     * @param _lastRewardRound From {BondingManager-Transcoder-lastRewardRound}\\n     */\\n    function checkpointBondingState(\\n        address _account,\\n        uint256 _startRound,\\n        uint256 _bondedAmount,\\n        address _delegateAddress,\\n        uint256 _delegatedAmount,\\n        uint256 _lastClaimRound,\\n        uint256 _lastRewardRound\\n    ) public virtual onlyBondingManager {\\n        if (_startRound != clock() + 1) {\\n            revert InvalidStartRound(_startRound, clock() + 1);\\n        } else if (_lastClaimRound >= _startRound) {\\n            revert FutureLastClaimRound(_lastClaimRound, _startRound - 1);\\n        }\\n\\n        BondingCheckpoint memory previous;\\n        if (hasCheckpoint(_account)) {\\n            previous = getBondingCheckpointAt(_account, _startRound);\\n        }\\n\\n        BondingCheckpointsByRound storage checkpoints = bondingCheckpoints[_account];\\n\\n        BondingCheckpoint memory bond = BondingCheckpoint({\\n            bondedAmount: _bondedAmount,\\n            delegateAddress: _delegateAddress,\\n            delegatedAmount: _delegatedAmount,\\n            lastClaimRound: _lastClaimRound,\\n            lastRewardRound: _lastRewardRound\\n        });\\n        checkpoints.data[_startRound] = bond;\\n\\n        // now store the startRound itself in the startRounds array to allow us\\n        // to find it and lookup in the above mapping\\n        checkpoints.startRounds.pushSorted(_startRound);\\n\\n        onCheckpointChanged(_account, previous, bond);\\n    }\\n\\n    function onCheckpointChanged(\\n        address _account,\\n        BondingCheckpoint memory previous,\\n        BondingCheckpoint memory current\\n    ) internal {\\n        address previousDelegate = previous.delegateAddress;\\n        address newDelegate = current.delegateAddress;\\n        if (previousDelegate != newDelegate) {\\n            emit DelegateChanged(_account, previousDelegate, newDelegate);\\n        }\\n\\n        bool isTranscoder = newDelegate == _account;\\n        bool wasTranscoder = previousDelegate == _account;\\n        if (isTranscoder) {\\n            emit DelegateVotesChanged(_account, previous.delegatedAmount, current.delegatedAmount);\\n        } else if (wasTranscoder) {\\n            // if the account stopped being a transcoder, we want to emit an event zeroing its \\\"delegate votes\\\"\\n            emit DelegateVotesChanged(_account, previous.delegatedAmount, 0);\\n        }\\n\\n        // Always send delegator events since transcoders are delegators themselves. The way our rewards work, the\\n        // delegator voting power calculated from events will only reflect their claimed stake without pending rewards.\\n        if (previous.bondedAmount != current.bondedAmount) {\\n            emit DelegatorVotesChanged(_account, previous.bondedAmount, current.bondedAmount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns whether an account already has any checkpoint.\\n     * @dev This is meant to be called by a checkpoint initialization script once we deploy the checkpointing logic for\\n     * the first time, so we can efficiently initialize the checkpoint state for all accounts in the system.\\n     */\\n    function hasCheckpoint(address _account) public view returns (bool) {\\n        return bondingCheckpoints[_account].startRounds.length > 0;\\n    }\\n\\n    /**\\n     * @notice Called by the BondingManager when the total active stake changes.\\n     * @dev This is called only from the {BondingManager-setCurrentRoundTotalActiveStake} function to set the total\\n     * active stake in the current round.\\n     * @param _totalStake From {BondingManager-currentRoundTotalActiveStake}\\n     * @param _round The round for which the total active stake is valid. This is normally the current round.\\n     */\\n    function checkpointTotalActiveStake(uint256 _totalStake, uint256 _round) public virtual onlyBondingManager {\\n        if (_round > clock()) {\\n            revert FutureTotalStakeCheckpoint(_round, clock());\\n        }\\n\\n        totalStakeCheckpoints.data[_round] = _totalStake;\\n        totalStakeCheckpoints.rounds.pushSorted(_round);\\n    }\\n\\n    // Historical stake access functions\\n\\n    /**\\n     * @dev Gets the checkpointed total active stake at a given round.\\n     * @param _round The round for which we want to get the total active stake.\\n     */\\n    function getTotalActiveStakeAt(uint256 _round) public view virtual returns (uint256) {\\n        if (_round > clock() + 1) {\\n            revert FutureLookup(_round, clock() + 1);\\n        }\\n\\n        uint256 exactCheckpoint = totalStakeCheckpoints.data[_round];\\n        if (exactCheckpoint > 0) {\\n            return exactCheckpoint;\\n        }\\n\\n        uint256[] storage initializedRounds = totalStakeCheckpoints.rounds;\\n        uint256 upper = initializedRounds.findUpperBound(_round);\\n        if (upper == 0) {\\n            // Return a zero voting power supply for any round before the first checkpoint. This also happens if there\\n            // are no checkpoints at all.\\n            return 0;\\n        } else if (upper < initializedRounds.length) {\\n            // Use the checkpoint from the next initialized round, which got the next total active stake checkpointed.\\n            uint256 nextInitedRound = initializedRounds[upper];\\n            return totalStakeCheckpoints.data[nextInitedRound];\\n        } else {\\n            // Here the _round is after any initialized round, so grab its stake from nextRoundTotalActiveStake()\\n            return bondingManager().nextRoundTotalActiveStake();\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets the bonding state of an account at a given round.\\n     * @dev In the case of delegators it is the amount they are delegating to a transcoder, while for transcoders this\\n     * includes all the stake that has been delegated to them (including self-delegated).\\n     * @param _account The account whose bonding state we want to get.\\n     * @param _round The round for which we want to get the bonding state. Normally a proposal's vote start round.\\n     * @return amount The active stake of the account at the given round including any accrued rewards. In case of\\n     * transcoders this also includes all the amount delegated towards them by other delegators.\\n     * @return delegateAddress The address the account delegated to. Will be equal to _account in case of transcoders.\\n     */\\n    function getBondingStateAt(address _account, uint256 _round)\\n        public\\n        view\\n        virtual\\n        returns (uint256 amount, address delegateAddress)\\n    {\\n        BondingCheckpoint storage bond = getBondingCheckpointAt(_account, _round);\\n\\n        delegateAddress = bond.delegateAddress;\\n        bool isTranscoder = delegateAddress == _account;\\n\\n        if (bond.bondedAmount == 0) {\\n            amount = 0;\\n        } else if (isTranscoder) {\\n            // Address is a registered transcoder so we use its delegated amount. This includes self and delegated stake\\n            // as well as any accrued rewards, even unclaimed ones\\n            amount = bond.delegatedAmount;\\n        } else {\\n            // Address is NOT a registered transcoder so we calculate its cumulative stake for the voting power\\n            amount = delegatorCumulativeStakeAt(bond, _round);\\n        }\\n    }\\n\\n    /**\\n     * @dev Gets the checkpointed bonding state of an account at a round. This works by looking for the last checkpoint\\n     * at or before the given round and using the checkpoint of that round. If there hasn't been checkpoints since then\\n     * it means that the state hasn't changed.\\n     * @param _account The account whose bonding state we want to get.\\n     * @param _round The round for which we want to get the bonding state.\\n     * @return The {BondingCheckpoint} pointer to the checkpoints storage.\\n     */\\n    function getBondingCheckpointAt(address _account, uint256 _round)\\n        internal\\n        view\\n        returns (BondingCheckpoint storage)\\n    {\\n        if (_round > clock() + 1) {\\n            revert FutureLookup(_round, clock() + 1);\\n        }\\n\\n        BondingCheckpointsByRound storage checkpoints = bondingCheckpoints[_account];\\n\\n        // Most of the time we will be calling this for a transcoder which checkpoints on every round through reward().\\n        // On those cases we will have a checkpoint for exactly the round we want, so optimize for that.\\n        BondingCheckpoint storage bond = checkpoints.data[_round];\\n        if (bond.bondedAmount > 0) {\\n            return bond;\\n        }\\n\\n        uint256 startRoundIdx = checkpoints.startRounds.findLowerBound(_round);\\n        if (startRoundIdx == checkpoints.startRounds.length) {\\n            // No checkpoint at or before _round, so return the zero BondingCheckpoint value. This also happens if there\\n            // are no checkpoints for _account. The voting power will be zero until the first checkpoint is made.\\n            return bond;\\n        }\\n\\n        uint256 startRound = checkpoints.startRounds[startRoundIdx];\\n        return checkpoints.data[startRound];\\n    }\\n\\n    /**\\n     * @dev Gets the cumulative stake of a delegator at any given round. Differently from the bonding manager\\n     * implementation, we can calculate the stake at any round through the use of the checkpointed state. It works by\\n     * re-using the bonding manager logic while changing only the way that we find the earning pool for the end round.\\n     * @param bond The {BondingCheckpoint} of the delegator at the given round.\\n     * @param _round The round for which we want to get the cumulative stake.\\n     * @return The cumulative stake of the delegator at the given round.\\n     */\\n    function delegatorCumulativeStakeAt(BondingCheckpoint storage bond, uint256 _round)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        EarningsPool.Data memory startPool = getTranscoderEarningsPoolForRound(\\n            bond.delegateAddress,\\n            bond.lastClaimRound\\n        );\\n\\n        (uint256 rewardRound, EarningsPool.Data memory endPool) = getLastTranscoderRewardsEarningsPool(\\n            bond.delegateAddress,\\n            _round\\n        );\\n\\n        if (rewardRound < bond.lastClaimRound) {\\n            // If the transcoder hasn't called reward() since the last time the delegator claimed earnings, there wil be\\n            // no rewards to add to the delegator's stake so we just return the originally bonded amount.\\n            return bond.bondedAmount;\\n        }\\n\\n        (uint256 stakeWithRewards, ) = EarningsPoolLIP36.delegatorCumulativeStakeAndFees(\\n            startPool,\\n            endPool,\\n            bond.bondedAmount,\\n            0\\n        );\\n        return stakeWithRewards;\\n    }\\n\\n    /**\\n     * @notice Returns the last initialized earning pool for a transcoder at a given round.\\n     * @dev Transcoders are just delegators with a self-delegation, so we find their last checkpoint before or at the\\n     * provided _round and use its lastRewardRound value to grab the calculated earning pool. The only case where this\\n     * returns a zero earning pool is if the transcoder had never called reward() before _round.\\n     * @param _transcoder Address of the transcoder to look for\\n     * @param _round Past round at which we want the valid earning pool from\\n     * @return rewardRound Round in which the returned earning pool was calculated.\\n     * @return pool EarningsPool.Data struct with the last initialized earning pool.\\n     */\\n    function getLastTranscoderRewardsEarningsPool(address _transcoder, uint256 _round)\\n        internal\\n        view\\n        returns (uint256 rewardRound, EarningsPool.Data memory pool)\\n    {\\n        BondingCheckpoint storage bond = getBondingCheckpointAt(_transcoder, _round);\\n        rewardRound = bond.lastRewardRound;\\n\\n        if (rewardRound > 0) {\\n            pool = getTranscoderEarningsPoolForRound(_transcoder, rewardRound);\\n\\n            if (pool.cumulativeRewardFactor == 0) {\\n                // Invalid state: a lastRewardRound is registered but there's no recorded earnings pool.\\n                revert MissingEarningsPool(_transcoder, rewardRound);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Proxy for {BondingManager-getTranscoderEarningsPoolForRound} that returns an EarningsPool.Data struct.\\n     */\\n    function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)\\n        internal\\n        view\\n        returns (EarningsPool.Data memory pool)\\n    {\\n        (\\n            pool.totalStake,\\n            pool.transcoderRewardCut,\\n            pool.transcoderFeeShare,\\n            pool.cumulativeRewardFactor,\\n            pool.cumulativeFeeFactor\\n        ) = bondingManager().getTranscoderEarningsPoolForRound(_transcoder, _round);\\n    }\\n\\n    // Manager/Controller helpers\\n\\n    /**\\n     * @dev Return BondingManager interface\\n     */\\n    function bondingManager() internal view returns (BondingManager) {\\n        return BondingManager(controller.getContract(keccak256(\\\"BondingManager\\\")));\\n    }\\n\\n    /**\\n     * @dev Return IRoundsManager interface\\n     */\\n    function roundsManager() internal view returns (IRoundsManager) {\\n        return IRoundsManager(controller.getContract(keccak256(\\\"RoundsManager\\\")));\\n    }\\n\\n    /**\\n     * @dev Return LivepeerToken interface\\n     */\\n    function livepeerToken() internal view returns (IERC20Metadata) {\\n        return IERC20Metadata(controller.getContract(keccak256(\\\"LivepeerToken\\\")));\\n    }\\n\\n    /**\\n     * @dev Ensure the sender is BondingManager\\n     */\\n    function _onlyBondingManager() internal view {\\n        if (msg.sender != address(bondingManager())) {\\n            revert InvalidCaller(msg.sender, address(bondingManager()));\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf9fc795a1566c12eb1ad2ee0386328803f686b85bbaefa86407b7aa3b52d9cd8\",\"license\":\"MIT\"},\"contracts/bonding/IBondingManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/**\\n * @title Interface for BondingManager\\n * TODO: switch to interface type\\n */\\ninterface IBondingManager {\\n    event TranscoderUpdate(address indexed transcoder, uint256 rewardCut, uint256 feeShare);\\n    event TranscoderActivated(address indexed transcoder, uint256 activationRound);\\n    event TranscoderDeactivated(address indexed transcoder, uint256 deactivationRound);\\n    event TranscoderSlashed(address indexed transcoder, address finder, uint256 penalty, uint256 finderReward);\\n    event Reward(address indexed transcoder, uint256 amount);\\n    event TreasuryReward(address indexed transcoder, address treasury, uint256 amount);\\n    event Bond(\\n        address indexed newDelegate,\\n        address indexed oldDelegate,\\n        address indexed delegator,\\n        uint256 additionalAmount,\\n        uint256 bondedAmount\\n    );\\n    event Unbond(\\n        address indexed delegate,\\n        address indexed delegator,\\n        uint256 unbondingLockId,\\n        uint256 amount,\\n        uint256 withdrawRound\\n    );\\n    event Rebond(address indexed delegate, address indexed delegator, uint256 unbondingLockId, uint256 amount);\\n    event TransferBond(\\n        address indexed oldDelegator,\\n        address indexed newDelegator,\\n        uint256 oldUnbondingLockId,\\n        uint256 newUnbondingLockId,\\n        uint256 amount\\n    );\\n    event WithdrawStake(address indexed delegator, uint256 unbondingLockId, uint256 amount, uint256 withdrawRound);\\n    event WithdrawFees(address indexed delegator, address recipient, uint256 amount);\\n    event EarningsClaimed(\\n        address indexed delegate,\\n        address indexed delegator,\\n        uint256 rewards,\\n        uint256 fees,\\n        uint256 startRound,\\n        uint256 endRound\\n    );\\n\\n    // Deprecated events\\n    // These event signatures can be used to construct the appropriate topic hashes to filter for past logs corresponding\\n    // to these deprecated events.\\n    // event Bond(address indexed delegate, address indexed delegator);\\n    // event Unbond(address indexed delegate, address indexed delegator);\\n    // event WithdrawStake(address indexed delegator);\\n    // event TranscoderUpdate(address indexed transcoder, uint256 pendingRewardCut, uint256 pendingFeeShare, uint256 pendingPricePerSegment, bool registered);\\n    // event TranscoderEvicted(address indexed transcoder);\\n    // event TranscoderResigned(address indexed transcoder);\\n\\n    // External functions\\n    function updateTranscoderWithFees(\\n        address _transcoder,\\n        uint256 _fees,\\n        uint256 _round\\n    ) external;\\n\\n    function slashTranscoder(\\n        address _transcoder,\\n        address _finder,\\n        uint256 _slashAmount,\\n        uint256 _finderFee\\n    ) external;\\n\\n    function setCurrentRoundTotalActiveStake() external;\\n\\n    // Public functions\\n    function getTranscoderPoolSize() external view returns (uint256);\\n\\n    function transcoderTotalStake(address _transcoder) external view returns (uint256);\\n\\n    function isActiveTranscoder(address _transcoder) external view returns (bool);\\n\\n    function getTotalBonded() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd76b4f24be3a14f28353774cbf6471164d0279ca2bdaf155cafc92760b1c932c\",\"license\":\"MIT\"},\"contracts/bonding/IBondingVotes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC6372Upgradeable.sol\\\";\\n\\nimport \\\"../treasury/IVotes.sol\\\";\\n\\n/**\\n * @title Interface for BondingVotes\\n */\\ninterface IBondingVotes is IERC6372Upgradeable, IVotes {\\n    error InvalidCaller(address caller, address required);\\n    error InvalidStartRound(uint256 checkpointRound, uint256 requiredRound);\\n    error FutureLastClaimRound(uint256 lastClaimRound, uint256 maxAllowed);\\n    error FutureTotalStakeCheckpoint(uint256 checkpointRound, uint256 maxAllowedRound);\\n\\n    error FutureLookup(uint256 queryRound, uint256 maxAllowed);\\n    error MissingEarningsPool(address transcoder, uint256 round);\\n\\n    // Indicates that the called function is not supported in this contract and should be performed through the\\n    // BondingManager instead. This is mostly used for IVotes delegation methods which must be bonds instead.\\n    error MustCallBondingManager(string bondingManagerFunction);\\n\\n    // ERC-20 Metadata\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    // BondingManager hooks\\n\\n    function checkpointBondingState(\\n        address _account,\\n        uint256 _startRound,\\n        uint256 _bondedAmount,\\n        address _delegateAddress,\\n        uint256 _delegatedAmount,\\n        uint256 _lastClaimRound,\\n        uint256 _lastRewardRound\\n    ) external;\\n\\n    function checkpointTotalActiveStake(uint256 _totalStake, uint256 _round) external;\\n\\n    // Historical stake access functions\\n\\n    function hasCheckpoint(address _account) external view returns (bool);\\n\\n    function getTotalActiveStakeAt(uint256 _round) external view returns (uint256);\\n\\n    function getBondingStateAt(address _account, uint256 _round)\\n        external\\n        view\\n        returns (uint256 amount, address delegateAddress);\\n}\\n\",\"keccak256\":\"0xb1d677711daffe76bf956e2b7af7f23f33c681fed3ff06f1c126eac645268d18\",\"license\":\"MIT\"},\"contracts/bonding/libraries/EarningsPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"../../libraries/MathUtils.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n * @title EarningsPool\\n * @dev Manages reward and fee pools for delegators and transcoders\\n */\\nlibrary EarningsPool {\\n    using SafeMath for uint256;\\n\\n    struct Data {\\n        uint256 totalStake; // Transcoder's total stake during the earnings pool's round\\n        uint256 transcoderRewardCut; // Transcoder's reward cut during the earnings pool's round\\n        uint256 transcoderFeeShare; // Transcoder's fee share during the earnings pool's round\\n        // LIP-36 (https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-36.md) fields\\n        // See EarningsPoolLIP36.sol\\n        uint256 cumulativeRewardFactor;\\n        uint256 cumulativeFeeFactor;\\n    }\\n\\n    /**\\n     * @dev Sets transcoderRewardCut and transcoderFeeshare for an EarningsPool\\n     * @param earningsPool Storage pointer to EarningsPool struct\\n     * @param _rewardCut Reward cut of transcoder during the earnings pool's round\\n     * @param _feeShare Fee share of transcoder during the earnings pool's round\\n     */\\n    function setCommission(\\n        EarningsPool.Data storage earningsPool,\\n        uint256 _rewardCut,\\n        uint256 _feeShare\\n    ) internal {\\n        earningsPool.transcoderRewardCut = _rewardCut;\\n        earningsPool.transcoderFeeShare = _feeShare;\\n    }\\n\\n    /**\\n     * @dev Sets totalStake for an EarningsPool\\n     * @param earningsPool Storage pointer to EarningsPool struct\\n     * @param _stake Total stake of the transcoder during the earnings pool's round\\n     */\\n    function setStake(EarningsPool.Data storage earningsPool, uint256 _stake) internal {\\n        earningsPool.totalStake = _stake;\\n    }\\n}\\n\",\"keccak256\":\"0x0a281920caf1429fc6afe7de303b8067c182190a450a190c8b9dc282aa7edfa0\",\"license\":\"MIT\"},\"contracts/bonding/libraries/EarningsPoolLIP36.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./EarningsPool.sol\\\";\\nimport \\\"../../libraries/PreciseMathUtils.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nlibrary EarningsPoolLIP36 {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @notice Update the cumulative fee factor stored in an earnings pool with new fees\\n     * @param earningsPool Storage pointer to EarningsPools.Data struct\\n     * @param _prevEarningsPool In-memory EarningsPool.Data struct that stores the previous cumulative reward and fee factors\\n     * @param _fees Amount of new fees\\n     */\\n    function updateCumulativeFeeFactor(\\n        EarningsPool.Data storage earningsPool,\\n        EarningsPool.Data memory _prevEarningsPool,\\n        uint256 _fees\\n    ) internal {\\n        uint256 prevCumulativeFeeFactor = _prevEarningsPool.cumulativeFeeFactor;\\n        uint256 prevCumulativeRewardFactor = _prevEarningsPool.cumulativeRewardFactor != 0\\n            ? _prevEarningsPool.cumulativeRewardFactor\\n            : PreciseMathUtils.percPoints(1, 1);\\n\\n        // Initialize the cumulativeFeeFactor when adding fees for the first time\\n        if (earningsPool.cumulativeFeeFactor == 0) {\\n            earningsPool.cumulativeFeeFactor = prevCumulativeFeeFactor.add(\\n                PreciseMathUtils.percOf(prevCumulativeRewardFactor, _fees, earningsPool.totalStake)\\n            );\\n            return;\\n        }\\n\\n        earningsPool.cumulativeFeeFactor = earningsPool.cumulativeFeeFactor.add(\\n            PreciseMathUtils.percOf(prevCumulativeRewardFactor, _fees, earningsPool.totalStake)\\n        );\\n    }\\n\\n    /**\\n     * @notice Update the cumulative reward factor stored in an earnings pool with new rewards\\n     * @param earningsPool Storage pointer to EarningsPool.Data struct\\n     * @param _prevEarningsPool Storage pointer to EarningsPool.Data struct that stores the previous cumulative reward factor\\n     * @param _rewards Amount of new rewards\\n     */\\n    function updateCumulativeRewardFactor(\\n        EarningsPool.Data storage earningsPool,\\n        EarningsPool.Data memory _prevEarningsPool,\\n        uint256 _rewards\\n    ) internal {\\n        uint256 prevCumulativeRewardFactor = _prevEarningsPool.cumulativeRewardFactor != 0\\n            ? _prevEarningsPool.cumulativeRewardFactor\\n            : PreciseMathUtils.percPoints(1, 1);\\n\\n        earningsPool.cumulativeRewardFactor = prevCumulativeRewardFactor.add(\\n            PreciseMathUtils.percOf(prevCumulativeRewardFactor, _rewards, earningsPool.totalStake)\\n        );\\n    }\\n\\n    /**\\n     * @notice Calculates a delegator's cumulative stake and fees using the LIP-36 earnings claiming algorithm.\\n     * @param _startPool The earning pool from the start round for the start cumulative factors. Normally this is the\\n     * earning pool from the {Delegator-lastclaimRound}+1 round, as the round where `bondedAmount` was measured.\\n     * @param _endPool The earning pool from the end round for the end cumulative factors\\n     * @param _stake The delegator initial stake before including earned rewards. Normally the {Delegator-bondedAmount}\\n     * @param _fees The delegator's initial fees before including earned fees\\n     * @return cStake , cFees where cStake is the delegator's cumulative stake including earned rewards and cFees is the\\n     * delegator's cumulative fees including earned fees\\n     */\\n    function delegatorCumulativeStakeAndFees(\\n        EarningsPool.Data memory _startPool,\\n        EarningsPool.Data memory _endPool,\\n        uint256 _stake,\\n        uint256 _fees\\n    ) internal pure returns (uint256 cStake, uint256 cFees) {\\n        // If the start cumulativeRewardFactor is 0 set the default value to PreciseMathUtils.percPoints(1, 1)\\n        if (_startPool.cumulativeRewardFactor == 0) {\\n            _startPool.cumulativeRewardFactor = PreciseMathUtils.percPoints(1, 1);\\n        }\\n\\n        // If the end cumulativeRewardFactor is 0 set the default value to PreciseMathUtils.percPoints(1, 1)\\n        if (_endPool.cumulativeRewardFactor == 0) {\\n            _endPool.cumulativeRewardFactor = PreciseMathUtils.percPoints(1, 1);\\n        }\\n\\n        cFees = _fees.add(\\n            PreciseMathUtils.percOf(\\n                _stake,\\n                _endPool.cumulativeFeeFactor.sub(_startPool.cumulativeFeeFactor),\\n                _startPool.cumulativeRewardFactor\\n            )\\n        );\\n\\n        cStake = PreciseMathUtils.percOf(_stake, _endPool.cumulativeRewardFactor, _startPool.cumulativeRewardFactor);\\n\\n        return (cStake, cFees);\\n    }\\n}\\n\",\"keccak256\":\"0xe4d2f9754d7d0d2d4642f30f2ea6d6ed588e78ebd7bdfb665fcd85c211f726a4\",\"license\":\"MIT\"},\"contracts/bonding/libraries/SortedArrays.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"../../libraries/MathUtils.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/Arrays.sol\\\";\\n\\n/**\\n * @title SortedArrays\\n * @dev Handles maintaining and looking up on sorted uint256 arrays.\\n */\\nlibrary SortedArrays {\\n    using Arrays for uint256[];\\n\\n    error DecreasingValues(uint256 newValue, uint256 lastValue);\\n\\n    /**\\n     * @notice Searches a sorted _array and returns the last element to be lower or equal to _val. If there is no such\\n     * element (all elements in array are higher than the searched element), the array length is returned.\\n     *\\n     * @dev This basically converts OpenZeppelin's {Arrays-findUpperBound} into findLowerBound, meaning it also uses a\\n     * binary search in the worst case after trying some shortcuts. Worst case time complexity is O(log n). The only\\n     * change being that the returned index points to the element lower or equal to _val, instead of higher or equal.\\n     * @param _array Array to search in\\n     * @param _val Value to search for\\n     * @return lower Index of the lower bound found in array\\n     */\\n    function findLowerBound(uint256[] storage _array, uint256 _val) internal view returns (uint256) {\\n        uint256 len = _array.length;\\n        if (len == 0) {\\n            return 0;\\n        }\\n\\n        if (_array[len - 1] <= _val) {\\n            return len - 1;\\n        }\\n\\n        uint256 upperIdx = _array.findUpperBound(_val);\\n\\n        // we already checked the last element above so the upper will always be inside the array\\n        assert(upperIdx < len);\\n\\n        // the exact value we were searching is in the array\\n        if (_array[upperIdx] == _val) {\\n            return upperIdx;\\n        }\\n\\n        // a 0 idx means that the first elem is already higher than the searched value (and not equal, checked above)\\n        if (upperIdx == 0) {\\n            return len;\\n        }\\n\\n        // the element at upperIdx is the first element higher than the value we want, so return the previous element\\n        return upperIdx - 1;\\n    }\\n\\n    /**\\n     * @notice Pushes a value into an already sorted array.\\n     * @dev Values must be pushed in increasing order as to avoid shifting values in the array. This function only\\n     * guarantees that the pushed value will not create duplicates nor make the array out of order.\\n     * @param array Array to push the value into\\n     * @param val Value to push into array. Must be greater than or equal to the highest (last) element.\\n     */\\n    function pushSorted(uint256[] storage array, uint256 val) internal {\\n        if (array.length == 0) {\\n            array.push(val);\\n        } else {\\n            uint256 last = array[array.length - 1];\\n\\n            // values must be pushed in order\\n            if (val < last) {\\n                revert DecreasingValues(val, last);\\n            }\\n\\n            // don't push duplicate values\\n            if (val != last) {\\n                array.push(val);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9034fa38481d1581d2a7cc577cfb9bd604c5893f79446ef36feafc5467f7b19a\",\"license\":\"MIT\"},\"contracts/libraries/MathUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nlibrary MathUtils {\\n    using SafeMath for uint256;\\n\\n    // Divisor used for representing percentages\\n    uint256 public constant PERC_DIVISOR = 1000000;\\n\\n    /**\\n     * @dev Returns whether an amount is a valid percentage out of PERC_DIVISOR\\n     * @param _amount Amount that is supposed to be a percentage\\n     */\\n    function validPerc(uint256 _amount) internal pure returns (bool) {\\n        return _amount <= PERC_DIVISOR;\\n    }\\n\\n    /**\\n     * @dev Compute percentage of a value with the percentage represented by a fraction\\n     * @param _amount Amount to take the percentage of\\n     * @param _fracNum Numerator of fraction representing the percentage\\n     * @param _fracDenom Denominator of fraction representing the percentage\\n     */\\n    function percOf(\\n        uint256 _amount,\\n        uint256 _fracNum,\\n        uint256 _fracDenom\\n    ) internal pure returns (uint256) {\\n        return _amount.mul(percPoints(_fracNum, _fracDenom)).div(PERC_DIVISOR);\\n    }\\n\\n    /**\\n     * @dev Compute percentage of a value with the percentage represented by a fraction over PERC_DIVISOR\\n     * @param _amount Amount to take the percentage of\\n     * @param _fracNum Numerator of fraction representing the percentage with PERC_DIVISOR as the denominator\\n     */\\n    function percOf(uint256 _amount, uint256 _fracNum) internal pure returns (uint256) {\\n        return _amount.mul(_fracNum).div(PERC_DIVISOR);\\n    }\\n\\n    /**\\n     * @dev Compute percentage representation of a fraction\\n     * @param _fracNum Numerator of fraction represeting the percentage\\n     * @param _fracDenom Denominator of fraction represeting the percentage\\n     */\\n    function percPoints(uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\\n        return _fracNum.mul(PERC_DIVISOR).div(_fracDenom);\\n    }\\n}\\n\",\"keccak256\":\"0x1df26c159dc63d804d3fda28e41b18487e8619009082c56e013aa6c9a58de253\",\"license\":\"MIT\"},\"contracts/libraries/PreciseMathUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nlibrary PreciseMathUtils {\\n    using SafeMath for uint256;\\n\\n    // Divisor used for representing percentages\\n    uint256 public constant PERC_DIVISOR = 10**27;\\n\\n    /**\\n     * @dev Returns whether an amount is a valid percentage out of PERC_DIVISOR\\n     * @param _amount Amount that is supposed to be a percentage\\n     */\\n    function validPerc(uint256 _amount) internal pure returns (bool) {\\n        return _amount <= PERC_DIVISOR;\\n    }\\n\\n    /**\\n     * @dev Compute percentage of a value with the percentage represented by a fraction\\n     * @param _amount Amount to take the percentage of\\n     * @param _fracNum Numerator of fraction representing the percentage\\n     * @param _fracDenom Denominator of fraction representing the percentage\\n     */\\n    function percOf(\\n        uint256 _amount,\\n        uint256 _fracNum,\\n        uint256 _fracDenom\\n    ) internal pure returns (uint256) {\\n        return _amount.mul(percPoints(_fracNum, _fracDenom)).div(PERC_DIVISOR);\\n    }\\n\\n    /**\\n     * @dev Compute percentage of a value with the percentage represented by a fraction over PERC_DIVISOR\\n     * @param _amount Amount to take the percentage of\\n     * @param _fracNum Numerator of fraction representing the percentage with PERC_DIVISOR as the denominator\\n     */\\n    function percOf(uint256 _amount, uint256 _fracNum) internal pure returns (uint256) {\\n        return _amount.mul(_fracNum).div(PERC_DIVISOR);\\n    }\\n\\n    /**\\n     * @dev Compute percentage representation of a fraction\\n     * @param _fracNum Numerator of fraction represeting the percentage\\n     * @param _fracDenom Denominator of fraction represeting the percentage\\n     */\\n    function percPoints(uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\\n        return _fracNum.mul(PERC_DIVISOR).div(_fracDenom);\\n    }\\n}\\n\",\"keccak256\":\"0x89ebb6e1db8b184d655c6c2726e3fd862a239767f8d249ca376b286ade675a9d\",\"license\":\"MIT\"},\"contracts/libraries/SortedDoublyLL.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n * @title A sorted doubly linked list with nodes sorted in descending order. Optionally accepts insert position hints\\n *\\n * Given a new node with a `key`, a hint is of the form `(prevId, nextId)` s.t. `prevId` and `nextId` are adjacent in the list.\\n * `prevId` is a node with a key >= `key` and `nextId` is a node with a key <= `key`. If the sender provides a hint that is a valid insert position\\n * the insert operation is a constant time storage write. However, the provided hint in a given transaction might be a valid insert position, but if other transactions are included first, when\\n * the given transaction is executed the provided hint may no longer be a valid insert position. For example, one of the nodes referenced might be removed or their keys may\\n * be updated such that the the pair of nodes in the hint no longer represent a valid insert position. If one of the nodes in the hint becomes invalid, we still try to use the other\\n * valid node as a starting point for finding the appropriate insert position. If both nodes in the hint become invalid, we use the head of the list as a starting point\\n * to find the appropriate insert position.\\n */\\nlibrary SortedDoublyLL {\\n    using SafeMath for uint256;\\n\\n    // Information for a node in the list\\n    struct Node {\\n        uint256 key; // Node's key used for sorting\\n        address nextId; // Id of next node (smaller key) in the list\\n        address prevId; // Id of previous node (larger key) in the list\\n    }\\n\\n    // Information for the list\\n    struct Data {\\n        address head; // Head of the list. Also the node in the list with the largest key\\n        address tail; // Tail of the list. Also the node in the list with the smallest key\\n        uint256 maxSize; // Maximum size of the list\\n        uint256 size; // Current size of the list\\n        mapping(address => Node) nodes; // Track the corresponding ids for each node in the list\\n    }\\n\\n    /**\\n     * @dev Set the maximum size of the list\\n     * @param _size Maximum size\\n     */\\n    function setMaxSize(Data storage self, uint256 _size) public {\\n        require(_size > self.maxSize, \\\"new max size must be greater than old max size\\\");\\n\\n        self.maxSize = _size;\\n    }\\n\\n    /**\\n     * @dev Add a node to the list\\n     * @param _id Node's id\\n     * @param _key Node's key\\n     * @param _prevId Id of previous node for the insert position\\n     * @param _nextId Id of next node for the insert position\\n     */\\n    function insert(\\n        Data storage self,\\n        address _id,\\n        uint256 _key,\\n        address _prevId,\\n        address _nextId\\n    ) public {\\n        // List must not be full\\n        require(!isFull(self), \\\"list is full\\\");\\n        // List must not already contain node\\n        require(!contains(self, _id), \\\"node already in list\\\");\\n        // Node id must not be null\\n        require(_id != address(0), \\\"node id is null\\\");\\n        // Key must be non-zero\\n        require(_key > 0, \\\"key is zero\\\");\\n\\n        address prevId = _prevId;\\n        address nextId = _nextId;\\n\\n        if (!validInsertPosition(self, _key, prevId, nextId)) {\\n            // Sender's hint was not a valid insert position\\n            // Use sender's hint to find a valid insert position\\n            (prevId, nextId) = findInsertPosition(self, _key, prevId, nextId);\\n        }\\n\\n        self.nodes[_id].key = _key;\\n\\n        if (prevId == address(0) && nextId == address(0)) {\\n            // Insert as head and tail\\n            self.head = _id;\\n            self.tail = _id;\\n        } else if (prevId == address(0)) {\\n            // Insert before `prevId` as the head\\n            self.nodes[_id].nextId = self.head;\\n            self.nodes[self.head].prevId = _id;\\n            self.head = _id;\\n        } else if (nextId == address(0)) {\\n            // Insert after `nextId` as the tail\\n            self.nodes[_id].prevId = self.tail;\\n            self.nodes[self.tail].nextId = _id;\\n            self.tail = _id;\\n        } else {\\n            // Insert at insert position between `prevId` and `nextId`\\n            self.nodes[_id].nextId = nextId;\\n            self.nodes[_id].prevId = prevId;\\n            self.nodes[prevId].nextId = _id;\\n            self.nodes[nextId].prevId = _id;\\n        }\\n\\n        self.size = self.size.add(1);\\n    }\\n\\n    /**\\n     * @dev Remove a node from the list\\n     * @param _id Node's id\\n     */\\n    function remove(Data storage self, address _id) public {\\n        // List must contain the node\\n        require(contains(self, _id), \\\"node not in list\\\");\\n\\n        if (self.size > 1) {\\n            // List contains more than a single node\\n            if (_id == self.head) {\\n                // The removed node is the head\\n                // Set head to next node\\n                self.head = self.nodes[_id].nextId;\\n                // Set prev pointer of new head to null\\n                self.nodes[self.head].prevId = address(0);\\n            } else if (_id == self.tail) {\\n                // The removed node is the tail\\n                // Set tail to previous node\\n                self.tail = self.nodes[_id].prevId;\\n                // Set next pointer of new tail to null\\n                self.nodes[self.tail].nextId = address(0);\\n            } else {\\n                // The removed node is neither the head nor the tail\\n                // Set next pointer of previous node to the next node\\n                self.nodes[self.nodes[_id].prevId].nextId = self.nodes[_id].nextId;\\n                // Set prev pointer of next node to the previous node\\n                self.nodes[self.nodes[_id].nextId].prevId = self.nodes[_id].prevId;\\n            }\\n        } else {\\n            // List contains a single node\\n            // Set the head and tail to null\\n            self.head = address(0);\\n            self.tail = address(0);\\n        }\\n\\n        delete self.nodes[_id];\\n        self.size = self.size.sub(1);\\n    }\\n\\n    /**\\n     * @dev Update the key of a node in the list\\n     * @param _id Node's id\\n     * @param _newKey Node's new key\\n     * @param _prevId Id of previous node for the new insert position\\n     * @param _nextId Id of next node for the new insert position\\n     */\\n    function updateKey(\\n        Data storage self,\\n        address _id,\\n        uint256 _newKey,\\n        address _prevId,\\n        address _nextId\\n    ) public {\\n        // List must contain the node\\n        require(contains(self, _id), \\\"node not in list\\\");\\n\\n        // Remove node from the list\\n        remove(self, _id);\\n\\n        if (_newKey > 0) {\\n            // Insert node if it has a non-zero key\\n            insert(self, _id, _newKey, _prevId, _nextId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Checks if the list contains a node\\n     * @param _id Address of transcoder\\n     * @return true if '_id' is in list\\n     */\\n    function contains(Data storage self, address _id) public view returns (bool) {\\n        // List only contains non-zero keys, so if key is non-zero the node exists\\n        return self.nodes[_id].key > 0;\\n    }\\n\\n    /**\\n     * @dev Checks if the list is full\\n     * @return true if list is full\\n     */\\n    function isFull(Data storage self) public view returns (bool) {\\n        return self.size == self.maxSize;\\n    }\\n\\n    /**\\n     * @dev Checks if the list is empty\\n     * @return true if list is empty\\n     */\\n    function isEmpty(Data storage self) public view returns (bool) {\\n        return self.size == 0;\\n    }\\n\\n    /**\\n     * @dev Returns the current size of the list\\n     * @return current size of the list\\n     */\\n    function getSize(Data storage self) public view returns (uint256) {\\n        return self.size;\\n    }\\n\\n    /**\\n     * @dev Returns the maximum size of the list\\n     */\\n    function getMaxSize(Data storage self) public view returns (uint256) {\\n        return self.maxSize;\\n    }\\n\\n    /**\\n     * @dev Returns the key of a node in the list\\n     * @param _id Node's id\\n     * @return key for node with '_id'\\n     */\\n    function getKey(Data storage self, address _id) public view returns (uint256) {\\n        return self.nodes[_id].key;\\n    }\\n\\n    /**\\n     * @dev Returns the first node in the list (node with the largest key)\\n     * @return address for the head of the list\\n     */\\n    function getFirst(Data storage self) public view returns (address) {\\n        return self.head;\\n    }\\n\\n    /**\\n     * @dev Returns the last node in the list (node with the smallest key)\\n     * @return address for the tail of the list\\n     */\\n    function getLast(Data storage self) public view returns (address) {\\n        return self.tail;\\n    }\\n\\n    /**\\n     * @dev Returns the next node (with a smaller key) in the list for a given node\\n     * @param _id Node's id\\n     * @return address for the node following node in list with '_id'\\n     */\\n    function getNext(Data storage self, address _id) public view returns (address) {\\n        return self.nodes[_id].nextId;\\n    }\\n\\n    /**\\n     * @dev Returns the previous node (with a larger key) in the list for a given node\\n     * @param _id Node's id\\n     * address for the node before node in list with '_id'\\n     */\\n    function getPrev(Data storage self, address _id) public view returns (address) {\\n        return self.nodes[_id].prevId;\\n    }\\n\\n    /**\\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given key\\n     * @param _key Node's key\\n     * @param _prevId Id of previous node for the insert position\\n     * @param _nextId Id of next node for the insert position\\n     * @return if the insert position is valid\\n     */\\n    function validInsertPosition(\\n        Data storage self,\\n        uint256 _key,\\n        address _prevId,\\n        address _nextId\\n    ) public view returns (bool) {\\n        if (_prevId == address(0) && _nextId == address(0)) {\\n            // `(null, null)` is a valid insert position if the list is empty\\n            return isEmpty(self);\\n        } else if (_prevId == address(0)) {\\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\\n            return self.head == _nextId && _key >= self.nodes[_nextId].key;\\n        } else if (_nextId == address(0)) {\\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\\n            return self.tail == _prevId && _key <= self.nodes[_prevId].key;\\n        } else {\\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_key` falls between the two nodes' keys\\n            return\\n                self.nodes[_prevId].nextId == _nextId &&\\n                self.nodes[_prevId].key >= _key &&\\n                _key >= self.nodes[_nextId].key;\\n        }\\n    }\\n\\n    /**\\n     * @dev Descend the list (larger keys to smaller keys) to find a valid insert position\\n     * @param _key Node's key\\n     * @param _startId Id of node to start ascending the list from\\n     */\\n    function descendList(\\n        Data storage self,\\n        uint256 _key,\\n        address _startId\\n    ) private view returns (address, address) {\\n        // If `_startId` is the head, check if the insert position is before the head\\n        if (self.head == _startId && _key >= self.nodes[_startId].key) {\\n            return (address(0), _startId);\\n        }\\n\\n        address prevId = _startId;\\n        address nextId = self.nodes[prevId].nextId;\\n\\n        // Descend the list until we reach the end or until we find a valid insert position\\n        while (prevId != address(0) && !validInsertPosition(self, _key, prevId, nextId)) {\\n            prevId = self.nodes[prevId].nextId;\\n            nextId = self.nodes[prevId].nextId;\\n        }\\n\\n        return (prevId, nextId);\\n    }\\n\\n    /**\\n     * @dev Ascend the list (smaller keys to larger keys) to find a valid insert position\\n     * @param _key Node's key\\n     * @param _startId Id of node to start descending the list from\\n     */\\n    function ascendList(\\n        Data storage self,\\n        uint256 _key,\\n        address _startId\\n    ) private view returns (address, address) {\\n        // If `_startId` is the tail, check if the insert position is after the tail\\n        if (self.tail == _startId && _key <= self.nodes[_startId].key) {\\n            return (_startId, address(0));\\n        }\\n\\n        address nextId = _startId;\\n        address prevId = self.nodes[nextId].prevId;\\n\\n        // Ascend the list until we reach the end or until we find a valid insertion point\\n        while (nextId != address(0) && !validInsertPosition(self, _key, prevId, nextId)) {\\n            nextId = self.nodes[nextId].prevId;\\n            prevId = self.nodes[nextId].prevId;\\n        }\\n\\n        return (prevId, nextId);\\n    }\\n\\n    /**\\n     * @dev Find the insert position for a new node with the given key\\n     * @param _key Node's key\\n     * @param _prevId Id of previous node for the insert position\\n     * @param _nextId Id of next node for the insert position\\n     */\\n    function findInsertPosition(\\n        Data storage self,\\n        uint256 _key,\\n        address _prevId,\\n        address _nextId\\n    ) private view returns (address, address) {\\n        address prevId = _prevId;\\n        address nextId = _nextId;\\n\\n        if (prevId != address(0)) {\\n            if (!contains(self, prevId) || _key > self.nodes[prevId].key) {\\n                // `prevId` does not exist anymore or now has a smaller key than the given key\\n                prevId = address(0);\\n            }\\n        }\\n\\n        if (nextId != address(0)) {\\n            if (!contains(self, nextId) || _key < self.nodes[nextId].key) {\\n                // `nextId` does not exist anymore or now has a larger key than the given key\\n                nextId = address(0);\\n            }\\n        }\\n\\n        if (prevId == address(0) && nextId == address(0)) {\\n            // No hint - descend list starting from head\\n            return descendList(self, _key, self.head);\\n        } else if (prevId == address(0)) {\\n            // No `prevId` for hint - ascend list starting from `nextId`\\n            return ascendList(self, _key, nextId);\\n        } else if (nextId == address(0)) {\\n            // No `nextId` for hint - descend list starting from `prevId`\\n            return descendList(self, _key, prevId);\\n        } else {\\n            // Descend list starting from `prevId`\\n            return descendList(self, _key, prevId);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdd26a77d6b76a7885f1a59c4b8cc6b8c1e21382012cbd9da136529160370e216\",\"license\":\"MIT\"},\"contracts/rounds/IRoundsManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/**\\n * @title RoundsManager interface\\n */\\ninterface IRoundsManager {\\n    // Events\\n    event NewRound(uint256 indexed round, bytes32 blockHash);\\n\\n    // Deprecated events\\n    // These event signatures can be used to construct the appropriate topic hashes to filter for past logs corresponding\\n    // to these deprecated events.\\n    // event NewRound(uint256 round)\\n\\n    // External functions\\n    function initializeRound() external;\\n\\n    function lipUpgradeRound(uint256 _lip) external view returns (uint256);\\n\\n    // Public functions\\n    function blockNum() external view returns (uint256);\\n\\n    function blockHash(uint256 _block) external view returns (bytes32);\\n\\n    function blockHashForRound(uint256 _round) external view returns (bytes32);\\n\\n    function currentRound() external view returns (uint256);\\n\\n    function currentRoundStartBlock() external view returns (uint256);\\n\\n    function currentRoundInitialized() external view returns (bool);\\n\\n    function currentRoundLocked() external view returns (bool);\\n}\\n\",\"keccak256\":\"0xfc453a476bb68b874c21678a128b46ffcad0af69008e0e3e857d46499214f75f\",\"license\":\"MIT\"},\"contracts/snapshots/IMerkleSnapshot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IMerkleSnapshot {\\n    function verify(\\n        bytes32 _id,\\n        bytes32[] calldata _proof,\\n        bytes32 _leaf\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xdc35b4faac2739b596a0773123dfe4dadfe3ecabc2ac48325b4732146cd90180\",\"license\":\"MIT\"},\"contracts/token/ILivepeerToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ILivepeerToken is IERC20 {\\n    function mint(address _to, uint256 _amount) external;\\n\\n    function burn(uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0xe9f35b4fd415a199993ac13e273149f9f8f2cf3d14c06927f05c40a9d6d048e1\",\"license\":\"MIT\"},\"contracts/token/IMinter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"../IController.sol\\\";\\n\\n/**\\n * @title Minter interface\\n */\\ninterface IMinter {\\n    // Events\\n    event SetCurrentRewardTokens(uint256 currentMintableTokens, uint256 currentInflation);\\n\\n    // External functions\\n    function createReward(uint256 _fracNum, uint256 _fracDenom) external returns (uint256);\\n\\n    function trustedTransferTokens(address _to, uint256 _amount) external;\\n\\n    function trustedBurnTokens(uint256 _amount) external;\\n\\n    function trustedWithdrawETH(address payable _to, uint256 _amount) external;\\n\\n    function depositETH() external payable returns (bool);\\n\\n    function setCurrentRewardTokens() external;\\n\\n    function currentMintableTokens() external view returns (uint256);\\n\\n    function currentMintedTokens() external view returns (uint256);\\n\\n    // Public functions\\n    function getController() external view returns (IController);\\n}\\n\",\"keccak256\":\"0x3fbb7a4239a8b5979fb4c45a41495e9694a9f454de82dca3cf6a14dfe71255c7\",\"license\":\"MIT\"},\"contracts/treasury/IVotes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC5805Upgradeable.sol\\\";\\n\\ninterface IVotes is IERC5805Upgradeable {\\n    /**\\n     * @dev Emitted when bonding change results in changes to a delegator's number of votes. This complements the events\\n     * from IERC5805 by also supporting voting power for the delegators themselves.\\n     */\\n    event DelegatorVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\\n\\n    function delegatedAt(address account, uint256 timepoint) external returns (address);\\n}\\n\",\"keccak256\":\"0xca0dcf84f2d79fabc12db5aa9ac0022c5de361e6f0d834bd56daf718979dcf5b\",\"license\":\"MIT\"},\"contracts/zeppelin/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x64f114689f2f161c4a4b8fc8442ab914436a33e6021bf17401eaeac73319a419\",\"license\":\"MIT\"},\"contracts/zeppelin/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Pausable\\n * @dev Base contract which allows children to implement an emergency stop mechanism.\\n */\\ncontract Pausable is Ownable {\\n    event Pause();\\n    event Unpause();\\n\\n    bool public paused;\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused);\\n        _;\\n    }\\n\\n    /**\\n     * @dev called by the owner to pause, triggers stopped state\\n     */\\n    function pause() public onlyOwner whenNotPaused {\\n        paused = true;\\n        emit Pause();\\n    }\\n\\n    /**\\n     * @dev called by the owner to unpause, returns to normal state\\n     */\\n    function unpause() public onlyOwner whenPaused {\\n        paused = false;\\n        emit Unpause();\\n    }\\n}\\n\",\"keccak256\":\"0xe9635fcac46c22547a08f6977a8c75e7341411f1201f60bdd4c79c26e6c286ef\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5060405161191138038061191183398101604081905261002f91610054565b600080546001600160a01b0319166001600160a01b0392909216919091179055610084565b60006020828403121561006657600080fd5b81516001600160a01b038116811461007d57600080fd5b9392505050565b61187e806100936000396000f3fe608060405234801561001057600080fd5b506004361061012c5760003560e01c806395d89b41116100ad578063d3df973311610071578063d3df9733146102e1578063e35c3e4314610311578063ef105c9114610324578063f77c479114610337578063f92e135b1461034a57600080fd5b806395d89b41146102655780639ab24eb01461026d578063b782c2bd14610280578063c3cda52014610293578063c656a01e146102a657600080fd5b8063587cde1e116100f4578063587cde1e146101e05780635c19a95c1461020b5780638e539e8c1461022057806391ddadf41461023357806392eefe9b1461025257600080fd5b806306fdde0314610131578063313ce5671461016d5780633a46b1a8146101875780634bf5d7e9146101a857806351720b41146101d7575b600080fd5b60408051808201909152600e81526d4c69766570656572205374616b6560901b60208201525b6040516101649190611477565b60405180910390f35b61017561035d565b60405160ff9091168152602001610164565b61019a6101953660046114c2565b6103dc565b604051908152602001610164565b6040805180820190915260138152721b5bd9194f5b1a5d995c19595c97dc9bdd5b99606a1b6020820152610157565b61019a60015481565b6101f36101ee3660046114ee565b6103f9565b6040516001600160a01b039091168152602001610164565b61021e6102193660046114ee565b610414565b005b61019a61022e36600461150b565b61044f565b61023b61045f565b60405165ffffffffffff9091168152602001610164565b61021e6102603660046114ee565b6104e1565b61015761053d565b61019a61027b3660046114ee565b6105bb565b61019a61028e36600461150b565b6105d6565b61021e6102a1366004611533565b610734565b6102d16102b43660046114ee565b6001600160a01b0316600090815260026020526040902054151590565b6040519015158152602001610164565b6102f46102ef3660046114c2565b610767565b604080519283526001600160a01b03909116602083015201610164565b61021e61031f36600461158f565b6107c7565b61021e6103323660046115f4565b610a03565b6000546101f3906001600160a01b031681565b6101f36103583660046114c2565b610a75565b6000610367610a87565b6001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b15801561039f57600080fd5b505afa1580156103b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d79190611616565b905090565b6000806103ee846102ef856001611649565b509150505b92915050565b60006103f38261040761045f565b65ffffffffffff16610a75565b60405163866cb42d60e01b815260040161044690602080825260049082015263189bdb9960e21b604082015260600190565b60405180910390fd5b60006103f361028e836001611649565b60006103d761046c610b24565b6001600160a01b0316638a19c8bc6040518163ffffffff1660e01b815260040160206040518083038186803b1580156104a457600080fd5b505afa1580156104b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104dc9190611661565b610b75565b6104e9610be0565b600080546001600160a01b0319166001600160a01b0383169081179091556040519081527f4ff638452bbf33c012645d18ae6f05515ff5f2d1dfb0cece8cbf018c60903f709060200160405180910390a150565b6060610547610a87565b6001600160a01b03166395d89b416040518163ffffffff1660e01b815260040160006040518083038186803b15801561057f57600080fd5b505afa158015610593573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526103d79190810190611690565b60006103f3826105c961045f565b65ffffffffffff166103dc565b60006105e061045f565b6105eb90600161173d565b65ffffffffffff16821115610638578161060361045f565b61060e90600161173d565b604051637f07449b60e01b8152600481019290925265ffffffffffff166024820152604401610446565b60008281526004602052604090205480156106535792915050565b600360006106618286610c3c565b90508061067357506000949350505050565b81548110156106b357600082828154811061069057610690611767565b600091825260208083209091015482526004905260409020549695505050505050565b6106bb610cdb565b6001600160a01b031663465501d36040518163ffffffff1660e01b815260040160206040518083038186803b1580156106f357600080fd5b505afa158015610707573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061072b9190611661565b95945050505050565b60405163866cb42d60e01b81526020600482015260076024820152663137b7322337b960c91b6044820152606401610446565b60008060006107768585610d2c565b600181015481546001600160a01b039182169450919250861683149061079f57600093506107be565b80156107b157816002015493506107be565b6107bb8286610df2565b93505b50509250929050565b6107cf610e70565b6107d761045f565b6107e290600161173d565b65ffffffffffff16861461082e57856107f961045f565b61080490600161173d565b60405163b986b59960e01b8152600481019290925265ffffffffffff166024820152604401610446565b858210610863578161084160018861177d565b6040516308384c5960e11b815260048101929092526024820152604401610446565b61089e6040518060a001604052806000815260200160006001600160a01b031681526020016000815260200160008152602001600081525090565b6001600160a01b0388166000908152600260205260409020541561090b576108c68888610d2c565b6040805160a0810182528254815260018301546001600160a01b0316602082015260028301549181019190915260038201546060820152600490910154608082015290505b6000600260008a6001600160a01b03166001600160a01b03168152602001908152602001600020905060006040518060a00160405280898152602001886001600160a01b03168152602001878152602001868152602001858152509050808260010160008b81526020019081526020016000206000820151816000015560208201518160010160006101000a8154816001600160a01b0302191690836001600160a01b031602179055506040820151816002015560608201518160030155608082015181600401559050506109ec8983600001610ec590919063ffffffff16565b6109f78a8483610f60565b50505050505050505050565b610a0b610e70565b610a1361045f565b65ffffffffffff16811115610a555780610a2b61045f565b604051637bc69a8f60e11b8152600481019290925265ffffffffffff166024820152604401610446565b6000818152600460205260409020829055610a71600382610ec5565b5050565b60008061072b846102ef856001611649565b60008054604051631c2d8fb360e31b81527f3443e257065fe41dd0e4d1f5a1b73a22a62e300962b57f30cddf41d0f8273ba760048201526001600160a01b039091169063e16c7d98906024015b60206040518083038186803b158015610aec57600080fd5b505afa158015610b00573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d79190611794565b60008054604051631c2d8fb360e31b81527fe8438ea868df48e3fc21f2f087b993c9b1837dc0f6135064161ce7d7a1701fe860048201526001600160a01b039091169063e16c7d9890602401610ad4565b600065ffffffffffff821115610bdc5760405162461bcd60e51b815260206004820152602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203460448201526538206269747360d01b6064820152608401610446565b5090565b6000546001600160a01b03163314610c3a5760405162461bcd60e51b815260206004820152601960248201527f63616c6c6572206d75737420626520436f6e74726f6c6c6572000000000000006044820152606401610446565b565b8154600090610c4d575060006103f3565b82546000905b80821015610c97576000610c6783836110e1565b905084610c748783611103565b541115610c8357809150610c91565b610c8e816001611649565b92505b50610c53565b600082118015610cba575083610cb786610cb260018661177d565b611103565b54145b15610cd357610cca60018361177d565b925050506103f3565b5090506103f3565b60008054604051631c2d8fb360e31b81527f2517d59a36a86548e38734e8ab416f42afff4bca78706a66ad65750dae7f9e3760048201526001600160a01b039091169063e16c7d9890602401610ad4565b6000610d3661045f565b610d4190600161173d565b65ffffffffffff16821115610d59578161060361045f565b6001600160a01b038316600090815260026020908152604080832085845260018101909252909120805415610d915791506103f39050565b6000610d9d8386611118565b8354909150811415610db3575091506103f39050565b6000836000018281548110610dca57610dca611767565b6000918252602080832090910154825260019095019094525050604090912091505092915050565b600182015460038301546000918291610e14916001600160a01b0316906111ce565b60018501549091506000908190610e34906001600160a01b0316866112a6565b915091508560030154821015610e51575050835491506103f39050565b6000610e64848389600001546000611341565b50979650505050505050565b610e78610cdb565b6001600160a01b0316336001600160a01b031614610c3a5733610e99610cdb565b6040516302d9d9c960e31b81526001600160a01b03928316600482015291166024820152604401610446565b8154610ee35781546001810183556000928352602090922090910155565b81546000908390610ef69060019061177d565b81548110610f0657610f06611767565b9060005260206000200154905080821015610f3e576040516328ffde6160e01b81526004810183905260248101829052604401610446565b808214610f5b578254600181018455600084815260209020018290555b505050565b602080830151908201516001600160a01b0380831690821614610fc857806001600160a01b0316826001600160a01b0316866001600160a01b03167f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f60405160405180910390a45b6001600160a01b0385811682821681149184161481156110315760408087015186820151825191825260208201526001600160a01b038916917fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724910160405180910390a2611080565b8015611080576040808701518151908152600060208201526001600160a01b038916917fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724910160405180910390a25b84518651146110d857855185516040516001600160a01b038a16927ff94a8b61475e2d24d0d739caf5475aacd0f93141192d582dabe94a96ddafe27a926110cf92918252602082015260400190565b60405180910390a25b50505050505050565b60006110f060028484186117b1565b6110fc90848416611649565b9392505050565b6000828152602081208201805b949350505050565b81546000908061112c5760009150506103f3565b828461113960018461177d565b8154811061114957611149611767565b90600052602060002001541161116c5761116460018261177d565b9150506103f3565b60006111788585610c3c565b9050818110611189576111896117d3565b8385828154811061119c5761119c611767565b906000526020600020015414156111b65791506103f39050565b806111c3575090506103f3565b61072b60018261177d565b6112006040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b611208610cdb565b60405163091153f160e21b81526001600160a01b0385811660048301526024820185905291909116906324454fc49060440160a06040518083038186803b15801561125257600080fd5b505afa158015611266573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061128a91906117e9565b6080860152606085015260408401526020830152815292915050565b60006112da6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b60006112e68585610d2c565b6004810154935090508215611339576112ff85846111ce565b915081606001516000141561133957604051634956ad3960e11b81526001600160a01b038616600482015260248101849052604401610446565b509250929050565b6000808560600151600014156113625761135c6001806113cf565b60608701525b606085015161137c576113766001806113cf565b60608601525b6113af6113a88561139e896080015189608001516113f190919063ffffffff16565b89606001516113fd565b8490611423565b90506113c484866060015188606001516113fd565b915094509492505050565b60006110fc826113eb856b033b2e3c9fd0803ce800000061142f565b9061143b565b60006110fc828461177d565b60006111106b033b2e3c9fd0803ce80000006113eb61141c86866113cf565b879061142f565b60006110fc8284611649565b60006110fc8284611829565b60006110fc82846117b1565b60005b8381101561146257818101518382015260200161144a565b83811115611471576000848401525b50505050565b6020815260008251806020840152611496816040850160208701611447565b601f01601f19169190910160400192915050565b6001600160a01b03811681146114bf57600080fd5b50565b600080604083850312156114d557600080fd5b82356114e0816114aa565b946020939093013593505050565b60006020828403121561150057600080fd5b81356110fc816114aa565b60006020828403121561151d57600080fd5b5035919050565b60ff811681146114bf57600080fd5b60008060008060008060c0878903121561154c57600080fd5b8635611557816114aa565b95506020870135945060408701359350606087013561157581611524565b9598949750929560808101359460a0909101359350915050565b600080600080600080600060e0888a0312156115aa57600080fd5b87356115b5816114aa565b9650602088013595506040880135945060608801356115d3816114aa565b9699959850939660808101359560a0820135955060c0909101359350915050565b6000806040838503121561160757600080fd5b50508035926020909101359150565b60006020828403121561162857600080fd5b81516110fc81611524565b634e487b7160e01b600052601160045260246000fd5b6000821982111561165c5761165c611633565b500190565b60006020828403121561167357600080fd5b5051919050565b634e487b7160e01b600052604160045260246000fd5b6000602082840312156116a257600080fd5b815167ffffffffffffffff808211156116ba57600080fd5b818401915084601f8301126116ce57600080fd5b8151818111156116e0576116e061167a565b604051601f8201601f19908116603f011681019083821181831017156117085761170861167a565b8160405282815287602084870101111561172157600080fd5b611732836020830160208801611447565b979650505050505050565b600065ffffffffffff80831681851680830382111561175e5761175e611633565b01949350505050565b634e487b7160e01b600052603260045260246000fd5b60008282101561178f5761178f611633565b500390565b6000602082840312156117a657600080fd5b81516110fc816114aa565b6000826117ce57634e487b7160e01b600052601260045260246000fd5b500490565b634e487b7160e01b600052600160045260246000fd5b600080600080600060a0868803121561180157600080fd5b5050835160208501516040860151606087015160809097015192989197509594509092509050565b600081600019048311821515161561184357611843611633565b50029056fea264697066735822122019abd13af003b355422255961d2fbbcfa04bebb44a97791528672e136c286f8364736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061012c5760003560e01c806395d89b41116100ad578063d3df973311610071578063d3df9733146102e1578063e35c3e4314610311578063ef105c9114610324578063f77c479114610337578063f92e135b1461034a57600080fd5b806395d89b41146102655780639ab24eb01461026d578063b782c2bd14610280578063c3cda52014610293578063c656a01e146102a657600080fd5b8063587cde1e116100f4578063587cde1e146101e05780635c19a95c1461020b5780638e539e8c1461022057806391ddadf41461023357806392eefe9b1461025257600080fd5b806306fdde0314610131578063313ce5671461016d5780633a46b1a8146101875780634bf5d7e9146101a857806351720b41146101d7575b600080fd5b60408051808201909152600e81526d4c69766570656572205374616b6560901b60208201525b6040516101649190611477565b60405180910390f35b61017561035d565b60405160ff9091168152602001610164565b61019a6101953660046114c2565b6103dc565b604051908152602001610164565b6040805180820190915260138152721b5bd9194f5b1a5d995c19595c97dc9bdd5b99606a1b6020820152610157565b61019a60015481565b6101f36101ee3660046114ee565b6103f9565b6040516001600160a01b039091168152602001610164565b61021e6102193660046114ee565b610414565b005b61019a61022e36600461150b565b61044f565b61023b61045f565b60405165ffffffffffff9091168152602001610164565b61021e6102603660046114ee565b6104e1565b61015761053d565b61019a61027b3660046114ee565b6105bb565b61019a61028e36600461150b565b6105d6565b61021e6102a1366004611533565b610734565b6102d16102b43660046114ee565b6001600160a01b0316600090815260026020526040902054151590565b6040519015158152602001610164565b6102f46102ef3660046114c2565b610767565b604080519283526001600160a01b03909116602083015201610164565b61021e61031f36600461158f565b6107c7565b61021e6103323660046115f4565b610a03565b6000546101f3906001600160a01b031681565b6101f36103583660046114c2565b610a75565b6000610367610a87565b6001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b15801561039f57600080fd5b505afa1580156103b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d79190611616565b905090565b6000806103ee846102ef856001611649565b509150505b92915050565b60006103f38261040761045f565b65ffffffffffff16610a75565b60405163866cb42d60e01b815260040161044690602080825260049082015263189bdb9960e21b604082015260600190565b60405180910390fd5b60006103f361028e836001611649565b60006103d761046c610b24565b6001600160a01b0316638a19c8bc6040518163ffffffff1660e01b815260040160206040518083038186803b1580156104a457600080fd5b505afa1580156104b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104dc9190611661565b610b75565b6104e9610be0565b600080546001600160a01b0319166001600160a01b0383169081179091556040519081527f4ff638452bbf33c012645d18ae6f05515ff5f2d1dfb0cece8cbf018c60903f709060200160405180910390a150565b6060610547610a87565b6001600160a01b03166395d89b416040518163ffffffff1660e01b815260040160006040518083038186803b15801561057f57600080fd5b505afa158015610593573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526103d79190810190611690565b60006103f3826105c961045f565b65ffffffffffff166103dc565b60006105e061045f565b6105eb90600161173d565b65ffffffffffff16821115610638578161060361045f565b61060e90600161173d565b604051637f07449b60e01b8152600481019290925265ffffffffffff166024820152604401610446565b60008281526004602052604090205480156106535792915050565b600360006106618286610c3c565b90508061067357506000949350505050565b81548110156106b357600082828154811061069057610690611767565b600091825260208083209091015482526004905260409020549695505050505050565b6106bb610cdb565b6001600160a01b031663465501d36040518163ffffffff1660e01b815260040160206040518083038186803b1580156106f357600080fd5b505afa158015610707573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061072b9190611661565b95945050505050565b60405163866cb42d60e01b81526020600482015260076024820152663137b7322337b960c91b6044820152606401610446565b60008060006107768585610d2c565b600181015481546001600160a01b039182169450919250861683149061079f57600093506107be565b80156107b157816002015493506107be565b6107bb8286610df2565b93505b50509250929050565b6107cf610e70565b6107d761045f565b6107e290600161173d565b65ffffffffffff16861461082e57856107f961045f565b61080490600161173d565b60405163b986b59960e01b8152600481019290925265ffffffffffff166024820152604401610446565b858210610863578161084160018861177d565b6040516308384c5960e11b815260048101929092526024820152604401610446565b61089e6040518060a001604052806000815260200160006001600160a01b031681526020016000815260200160008152602001600081525090565b6001600160a01b0388166000908152600260205260409020541561090b576108c68888610d2c565b6040805160a0810182528254815260018301546001600160a01b0316602082015260028301549181019190915260038201546060820152600490910154608082015290505b6000600260008a6001600160a01b03166001600160a01b03168152602001908152602001600020905060006040518060a00160405280898152602001886001600160a01b03168152602001878152602001868152602001858152509050808260010160008b81526020019081526020016000206000820151816000015560208201518160010160006101000a8154816001600160a01b0302191690836001600160a01b031602179055506040820151816002015560608201518160030155608082015181600401559050506109ec8983600001610ec590919063ffffffff16565b6109f78a8483610f60565b50505050505050505050565b610a0b610e70565b610a1361045f565b65ffffffffffff16811115610a555780610a2b61045f565b604051637bc69a8f60e11b8152600481019290925265ffffffffffff166024820152604401610446565b6000818152600460205260409020829055610a71600382610ec5565b5050565b60008061072b846102ef856001611649565b60008054604051631c2d8fb360e31b81527f3443e257065fe41dd0e4d1f5a1b73a22a62e300962b57f30cddf41d0f8273ba760048201526001600160a01b039091169063e16c7d98906024015b60206040518083038186803b158015610aec57600080fd5b505afa158015610b00573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d79190611794565b60008054604051631c2d8fb360e31b81527fe8438ea868df48e3fc21f2f087b993c9b1837dc0f6135064161ce7d7a1701fe860048201526001600160a01b039091169063e16c7d9890602401610ad4565b600065ffffffffffff821115610bdc5760405162461bcd60e51b815260206004820152602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203460448201526538206269747360d01b6064820152608401610446565b5090565b6000546001600160a01b03163314610c3a5760405162461bcd60e51b815260206004820152601960248201527f63616c6c6572206d75737420626520436f6e74726f6c6c6572000000000000006044820152606401610446565b565b8154600090610c4d575060006103f3565b82546000905b80821015610c97576000610c6783836110e1565b905084610c748783611103565b541115610c8357809150610c91565b610c8e816001611649565b92505b50610c53565b600082118015610cba575083610cb786610cb260018661177d565b611103565b54145b15610cd357610cca60018361177d565b925050506103f3565b5090506103f3565b60008054604051631c2d8fb360e31b81527f2517d59a36a86548e38734e8ab416f42afff4bca78706a66ad65750dae7f9e3760048201526001600160a01b039091169063e16c7d9890602401610ad4565b6000610d3661045f565b610d4190600161173d565b65ffffffffffff16821115610d59578161060361045f565b6001600160a01b038316600090815260026020908152604080832085845260018101909252909120805415610d915791506103f39050565b6000610d9d8386611118565b8354909150811415610db3575091506103f39050565b6000836000018281548110610dca57610dca611767565b6000918252602080832090910154825260019095019094525050604090912091505092915050565b600182015460038301546000918291610e14916001600160a01b0316906111ce565b60018501549091506000908190610e34906001600160a01b0316866112a6565b915091508560030154821015610e51575050835491506103f39050565b6000610e64848389600001546000611341565b50979650505050505050565b610e78610cdb565b6001600160a01b0316336001600160a01b031614610c3a5733610e99610cdb565b6040516302d9d9c960e31b81526001600160a01b03928316600482015291166024820152604401610446565b8154610ee35781546001810183556000928352602090922090910155565b81546000908390610ef69060019061177d565b81548110610f0657610f06611767565b9060005260206000200154905080821015610f3e576040516328ffde6160e01b81526004810183905260248101829052604401610446565b808214610f5b578254600181018455600084815260209020018290555b505050565b602080830151908201516001600160a01b0380831690821614610fc857806001600160a01b0316826001600160a01b0316866001600160a01b03167f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f60405160405180910390a45b6001600160a01b0385811682821681149184161481156110315760408087015186820151825191825260208201526001600160a01b038916917fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724910160405180910390a2611080565b8015611080576040808701518151908152600060208201526001600160a01b038916917fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724910160405180910390a25b84518651146110d857855185516040516001600160a01b038a16927ff94a8b61475e2d24d0d739caf5475aacd0f93141192d582dabe94a96ddafe27a926110cf92918252602082015260400190565b60405180910390a25b50505050505050565b60006110f060028484186117b1565b6110fc90848416611649565b9392505050565b6000828152602081208201805b949350505050565b81546000908061112c5760009150506103f3565b828461113960018461177d565b8154811061114957611149611767565b90600052602060002001541161116c5761116460018261177d565b9150506103f3565b60006111788585610c3c565b9050818110611189576111896117d3565b8385828154811061119c5761119c611767565b906000526020600020015414156111b65791506103f39050565b806111c3575090506103f3565b61072b60018261177d565b6112006040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b611208610cdb565b60405163091153f160e21b81526001600160a01b0385811660048301526024820185905291909116906324454fc49060440160a06040518083038186803b15801561125257600080fd5b505afa158015611266573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061128a91906117e9565b6080860152606085015260408401526020830152815292915050565b60006112da6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b60006112e68585610d2c565b6004810154935090508215611339576112ff85846111ce565b915081606001516000141561133957604051634956ad3960e11b81526001600160a01b038616600482015260248101849052604401610446565b509250929050565b6000808560600151600014156113625761135c6001806113cf565b60608701525b606085015161137c576113766001806113cf565b60608601525b6113af6113a88561139e896080015189608001516113f190919063ffffffff16565b89606001516113fd565b8490611423565b90506113c484866060015188606001516113fd565b915094509492505050565b60006110fc826113eb856b033b2e3c9fd0803ce800000061142f565b9061143b565b60006110fc828461177d565b60006111106b033b2e3c9fd0803ce80000006113eb61141c86866113cf565b879061142f565b60006110fc8284611649565b60006110fc8284611829565b60006110fc82846117b1565b60005b8381101561146257818101518382015260200161144a565b83811115611471576000848401525b50505050565b6020815260008251806020840152611496816040850160208701611447565b601f01601f19169190910160400192915050565b6001600160a01b03811681146114bf57600080fd5b50565b600080604083850312156114d557600080fd5b82356114e0816114aa565b946020939093013593505050565b60006020828403121561150057600080fd5b81356110fc816114aa565b60006020828403121561151d57600080fd5b5035919050565b60ff811681146114bf57600080fd5b60008060008060008060c0878903121561154c57600080fd5b8635611557816114aa565b95506020870135945060408701359350606087013561157581611524565b9598949750929560808101359460a0909101359350915050565b600080600080600080600060e0888a0312156115aa57600080fd5b87356115b5816114aa565b9650602088013595506040880135945060608801356115d3816114aa565b9699959850939660808101359560a0820135955060c0909101359350915050565b6000806040838503121561160757600080fd5b50508035926020909101359150565b60006020828403121561162857600080fd5b81516110fc81611524565b634e487b7160e01b600052601160045260246000fd5b6000821982111561165c5761165c611633565b500190565b60006020828403121561167357600080fd5b5051919050565b634e487b7160e01b600052604160045260246000fd5b6000602082840312156116a257600080fd5b815167ffffffffffffffff808211156116ba57600080fd5b818401915084601f8301126116ce57600080fd5b8151818111156116e0576116e061167a565b604051601f8201601f19908116603f011681019083821181831017156117085761170861167a565b8160405282815287602084870101111561172157600080fd5b611732836020830160208801611447565b979650505050505050565b600065ffffffffffff80831681851680830382111561175e5761175e611633565b01949350505050565b634e487b7160e01b600052603260045260246000fd5b60008282101561178f5761178f611633565b500390565b6000602082840312156117a657600080fd5b81516110fc816114aa565b6000826117ce57634e487b7160e01b600052601260045260246000fd5b500490565b634e487b7160e01b600052600160045260246000fd5b600080600080600060a0868803121561180157600080fd5b5050835160208501516040860151606087015160809097015192989197509594509092509050565b600081600019048311821515161561184357611843611633565b50029056fea264697066735822122019abd13af003b355422255961d2fbbcfa04bebb44a97791528672e136c286f8364736f6c63430008090033",
  "devdoc": {
    "details": "Checkpointing logic for BondingManager state for historical stake calculations.",
    "kind": "dev",
    "methods": {
      "checkpointBondingState(address,uint256,uint256,address,uint256,uint256,uint256)": {
        "details": "Since we checkpoint \"delegator\" and \"transcoder\" states, this is called both for the delegator and for the transcoder when any change is made to the bonds, including when rewards are calculated or claimed.",
        "params": {
          "_account": "The account whose bonding state changed",
          "_bondedAmount": "From {BondingManager-Delegator-bondedAmount}",
          "_delegateAddress": "From {BondingManager-Delegator-delegateAddress}",
          "_delegatedAmount": "From {BondingManager-Transcoder-delegatedAmount}",
          "_lastClaimRound": "From {BondingManager-Delegator-lastClaimRound}",
          "_lastRewardRound": "From {BondingManager-Transcoder-lastRewardRound}",
          "_startRound": "The round from which the bonding state will be active. This is normally the next round."
        }
      },
      "checkpointTotalActiveStake(uint256,uint256)": {
        "details": "This is called only from the {BondingManager-setCurrentRoundTotalActiveStake} function to set the total active stake in the current round.",
        "params": {
          "_round": "The round for which the total active stake is valid. This is normally the current round.",
          "_totalStake": "From {BondingManager-currentRoundTotalActiveStake}"
        }
      },
      "decimals()": {
        "details": "Returns the decimals places of the token."
      },
      "delegatedAt(address,uint256)": {
        "details": "This is an addition to the IERC5805 interface to support our custom vote counting logic that allows delegators to override their transcoders votes. See {GaovernorCountingOverridable-_handleVoteOverrides}.Keep in mind that since this function should return the delegate at the end of the _round (or timepoint in OZ terms), we need to fetch the bonding state at the next round instead. That because the bonding state reflects the active stake in the current round, which is the snapshotted stake from the end of the previous round."
      },
      "getBondingStateAt(address,uint256)": {
        "details": "In the case of delegators it is the amount they are delegating to a transcoder, while for transcoders this includes all the stake that has been delegated to them (including self-delegated).",
        "params": {
          "_account": "The account whose bonding state we want to get.",
          "_round": "The round for which we want to get the bonding state. Normally a proposal's vote start round."
        },
        "returns": {
          "amount": "The active stake of the account at the given round including any accrued rewards. In case of transcoders this also includes all the amount delegated towards them by other delegators.",
          "delegateAddress": "The address the account delegated to. Will be equal to _account in case of transcoders."
        }
      },
      "getPastTotalSupply(uint256)": {
        "details": "This value is the sum of all *active* stake, which is not necessarily the sum of all voting power. Bonded stake that is not part of the top 100 active transcoder set is still given voting power, but is not considered here.Keep in mind that since this function should return the votes at the end of the _round (or timepoint in OZ terms), we need to fetch the total active stake at the next round instead. That because the active stake in the current round is the snapshotted stake from the end of the previous round."
      },
      "getPastVotes(address,uint256)": {
        "details": "Keep in mind that since this function should return the votes at the end of the _round (or timepoint in OZ terms), we need to fetch the bonding state at the next round instead. That because the bonding state reflects the active stake in the current round, which is the snapshotted stake from the end of the previous round."
      },
      "getTotalActiveStakeAt(uint256)": {
        "details": "Gets the checkpointed total active stake at a given round.",
        "params": {
          "_round": "The round for which we want to get the total active stake."
        }
      },
      "hasCheckpoint(address)": {
        "details": "This is meant to be called by a checkpoint initialization script once we deploy the checkpointing logic for the first time, so we can efficiently initialize the checkpoint state for all accounts in the system."
      },
      "name()": {
        "details": "Returns the name of the token."
      },
      "setController(address)": {
        "params": {
          "_controller": "Controller contract address"
        }
      },
      "symbol()": {
        "details": "Returns the symbol of the token."
      }
    },
    "stateVariables": {
      "bondingCheckpoints": {
        "details": "Checkpoints by account (delegators and transcoders)."
      },
      "totalStakeCheckpoints": {
        "details": "Total active stake checkpoints."
      }
    },
    "title": "BondingVotes",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "CLOCK_MODE()": {
        "notice": "Machine-readable description of the clock as specified in EIP-6372."
      },
      "checkpointBondingState(address,uint256,uint256,address,uint256,uint256,uint256)": {
        "notice": "Called by the BondingManager when the bonding state of an account changes."
      },
      "checkpointTotalActiveStake(uint256,uint256)": {
        "notice": "Called by the BondingManager when the total active stake changes."
      },
      "clock()": {
        "notice": "Clock is set to match the current round, which is the checkpointing  method implemented here."
      },
      "delegate(address)": {
        "notice": "Delegation through BondingVotes is not supported."
      },
      "delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)": {
        "notice": "Delegation through BondingVotes is not supported."
      },
      "delegatedAt(address,uint256)": {
        "notice": "Returns the delegate that _account had chosen in a specific round in the past. See `delegates()` above for more details."
      },
      "delegates(address)": {
        "notice": "Returns the delegate that _account has chosen. This means the delegated transcoder address in case of delegators, and the account's own address for transcoders (self-delegated)."
      },
      "getBondingStateAt(address,uint256)": {
        "notice": "Gets the bonding state of an account at a given round."
      },
      "getPastTotalSupply(uint256)": {
        "notice": "Returns the total supply of votes available at a specific round in the past."
      },
      "getPastVotes(address,uint256)": {
        "notice": "Returns the amount of votes that `_account` had at a specific moment in the past. If the `clock()` is configured to use block numbers, this will return the value at the end of the corresponding block."
      },
      "getVotes(address)": {
        "notice": "Returns the current amount of votes that `_account` has."
      },
      "hasCheckpoint(address)": {
        "notice": "Returns whether an account already has any checkpoint."
      },
      "setController(address)": {
        "notice": "Set controller. Only callable by current controller"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 18792,
        "contract": "contracts/bonding/BondingVotes.sol:BondingVotes",
        "label": "controller",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(IController)18767"
      },
      {
        "astId": 18974,
        "contract": "contracts/bonding/BondingVotes.sol:BondingVotes",
        "label": "targetContractId",
        "offset": 0,
        "slot": "1",
        "type": "t_bytes32"
      },
      {
        "astId": 22918,
        "contract": "contracts/bonding/BondingVotes.sol:BondingVotes",
        "label": "bondingCheckpoints",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_struct(BondingCheckpointsByRound)22904_storage)"
      },
      {
        "astId": 22922,
        "contract": "contracts/bonding/BondingVotes.sol:BondingVotes",
        "label": "totalStakeCheckpoints",
        "offset": 0,
        "slot": "3",
        "type": "t_struct(TotalActiveStakeByRound)22912_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IController)18767": {
        "encoding": "inplace",
        "label": "contract IController",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_struct(BondingCheckpointsByRound)22904_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct BondingVotes.BondingCheckpointsByRound)",
        "numberOfBytes": "32",
        "value": "t_struct(BondingCheckpointsByRound)22904_storage"
      },
      "t_mapping(t_uint256,t_struct(BondingCheckpoint)22895_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct BondingVotes.BondingCheckpoint)",
        "numberOfBytes": "32",
        "value": "t_struct(BondingCheckpoint)22895_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(BondingCheckpoint)22895_storage": {
        "encoding": "inplace",
        "label": "struct BondingVotes.BondingCheckpoint",
        "members": [
          {
            "astId": 22882,
            "contract": "contracts/bonding/BondingVotes.sol:BondingVotes",
            "label": "bondedAmount",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 22885,
            "contract": "contracts/bonding/BondingVotes.sol:BondingVotes",
            "label": "delegateAddress",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 22888,
            "contract": "contracts/bonding/BondingVotes.sol:BondingVotes",
            "label": "delegatedAmount",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 22891,
            "contract": "contracts/bonding/BondingVotes.sol:BondingVotes",
            "label": "lastClaimRound",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 22894,
            "contract": "contracts/bonding/BondingVotes.sol:BondingVotes",
            "label": "lastRewardRound",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(BondingCheckpointsByRound)22904_storage": {
        "encoding": "inplace",
        "label": "struct BondingVotes.BondingCheckpointsByRound",
        "members": [
          {
            "astId": 22898,
            "contract": "contracts/bonding/BondingVotes.sol:BondingVotes",
            "label": "startRounds",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 22903,
            "contract": "contracts/bonding/BondingVotes.sol:BondingVotes",
            "label": "data",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint256,t_struct(BondingCheckpoint)22895_storage)"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(TotalActiveStakeByRound)22912_storage": {
        "encoding": "inplace",
        "label": "struct BondingVotes.TotalActiveStakeByRound",
        "members": [
          {
            "astId": 22907,
            "contract": "contracts/bonding/BondingVotes.sol:BondingVotes",
            "label": "rounds",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 22911,
            "contract": "contracts/bonding/BondingVotes.sol:BondingVotes",
            "label": "data",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint256,t_uint256)"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}